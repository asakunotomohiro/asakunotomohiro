# 正規表現の利用で得た知見をすべてここにメモを残す。

[個人メモ(総合的な優先度の高いメモ)](#memo99999)  


## テキストエディタ
利用しているテキストエディタで正規表現が使えるため、そのエディタごとにも記録を付けていきたい。  

* [Vim](https://vim-jp.org/vimdoc-ja/pattern.html)  
* [秀丸エディタ](https://help.maruo.co.jp/hidemaru/html/190_CmdSearch_Regular.html)  
* [サクラエディタ](https://sakura-editor.github.io/help/HLP000089.html)  

それぞれにエディタでの正規表現は、下記書籍のなかで解説している内容に合うのがあれば、それに埋め込む。  
なければ、別途考える(分けるしかないのだろうが・・・)。  

[言語別用語など](#regularLanguageGeneralTermsLanguage)。

## プログラミング言語
プログラミング言語にも独特の方言があるため、言語ごとにも記録を残していきたい。  
しかし、下記書籍のなかに記録していく(個別に分けるのは非効率だろうからな)。  
そして、できることならば、JavaなどよりもPerlを優先したい。  
その理由は、上記エディタの[Vim](#regularLanguageGeneralTermsLanguagevim)・[サクラエディタ](#regularLanguageGeneralTermsLanguagesakura)の3種類のうち2種類がPerl互換の正規表現対応している。  
だからなんだって話だが・・・。  

## 書籍に追記していくときの注意事項。
以下のひな形を使い、どの形式にも対応できるようにする。  

<details><summary>ひな形(目次もどき)</summary>

以下のひな形を使う。  
必要に応じて必要な言語(もしくはコマンドなど)を使うつもりで、使わないものは削除する。  
ただし、`Vim`・`秀丸エディタ`・`サクラエディタ`・`grep`・`Perl`は、必ず付けておくこととする。  

    #### [タイトル]
    [大まかな概要を記述]

    以下、言語ごとの細かい方言(違い)を説明する。  
    * 一覧  
      * [Vim](#regularDesktopReferenceVim[大本の番号])  
      * [秀丸](#regularDesktopReferenceHidemaru[大本の番号])  
      * [サクラエディタ](#regularDesktopReferenceSakura[大本の番号])  
      * [grep](#regularDesktopReferenceGrep[大本の番号])  
      * [Go](#regularDesktopReferenceGo[大本の番号])  
      * [Perl](#regularDesktopReferencePerl[大本の番号])  
      * [AutoHotKey](#regularDesktopReferenceAutohotkey[大本の番号])  
      * [C#](#regularDesktopReferenceCSharp[大本の番号])  
      * [egrep](#regularDesktopReferenceEgrep[大本の番号])  
      * [sed](#regularDesktopReferencesed[大本の番号])  
      * [awk](#regularDesktopReferenceAwk[大本の番号])  
      * [Java](#regularDesktopReferenceJava[大本の番号])  
      * [Python](#regularDesktopReferencePython[大本の番号])  
      * [Vim Script](#regularDesktopReferenceVimscript[大本の番号])  
      * [Godot](#regularDesktopReferenceGodot[大本の番号])  
      * [C](#regularDesktopReferenceClang[大本の番号])  
      * [C++](#regularDesktopReferenceCplusplus[大本の番号])  
      * [Rust](#regularDesktopReferenceRust[大本の番号])  
      * [Tcl](#regularDesktopReferenceTcl[大本の番号])  
      * [.Net](#regularDesktopReferenceDotNet[大本の番号])  
      * [JavaScript](#regularDesktopReferenceJavascript[大本の番号])  
      * [Ruby](#regularDesktopReferenceRuby[大本の番号])  
      * [PHP](#regularDesktopReferencePhp[大本の番号])  
      * [SQL](#regularDesktopReferenceSql[大本の番号])  
      * [Visual Basic](#regularDesktopReferenceVisualbasic[大本の番号])  
      * [VBScript](#regularDesktopReferenceVbscript[大本の番号])  
      * [ECMAScript](#regularDesktopReferenceEcmascript[大本の番号])  
      * [elisp](#regularDesktopReferenceElisp[大本の番号])  
      * [ライブラリ](#regularDesktopReferenceLibrarie[大本の番号])  

    <a name="regularDesktopReferenceVim[大本の番号]"></a>
    ##### Vim

    <a name="regularDesktopReferenceHidemaru[大本の番号]"></a>
    ##### 秀丸

    <a name="regularDesktopReferenceSakura[大本の番号]"></a>
    ##### サクラエディタ

    <a name="regularDesktopReferenceGrep[大本の番号]"></a>
    ##### grep

    <a name="regularDesktopReferenceGo[大本の番号]"></a>
    ##### Go

    <a name="regularDesktopReferencePerl[大本の番号]"></a>
    ##### Perl

    <a name="regularDesktopReferenceAutohotkey[大本の番号]"></a>
    ##### AutoHotKey

    <a name="regularDesktopReferenceCSharp[大本の番号]"></a>
    ##### C#

    <a name="regularDesktopReferenceRust[大本の番号]"></a>
    ##### Rust

    <a name="regularDesktopReferenceEgrep[大本の番号]"></a>
    ##### egrep

    <a name="regularDesktopReferencesed[大本の番号]"></a>
    ##### sed

    <a name="regularDesktopReferenceAwk[大本の番号]"></a>
    ##### awk

    <a name="regularDesktopReferenceJava[大本の番号]"></a>
    ##### Java

    <a name="regularDesktopReferenceVimscript[大本の番号]"></a>
    ##### Vim Script

    <a name="regularDesktopReferencePython[大本の番号]"></a>
    ##### Python

    <a name="regularDesktopReferenceVba[大本の番号]"></a>
    ##### VBA

    <a name="regularDesktopReferenceClang[大本の番号]"></a>
    ##### C

    <a name="regularDesktopReferenceCplusplus[大本の番号]"></a>
    ##### C++

    <a name="regularDesktopReferenceTcl[大本の番号]"></a>
    ##### Tcl

    <a name="regularDesktopReferenceGodot[大本の番号]"></a>
    ##### Godot

    <a name="regularDesktopReferenceDotNet[大本の番号]"></a>
    ##### .Net

    <a name="regularDesktopReferenceVisualbasic[大本の番号]"></a>
    ##### Visual Basic

    <a name="regularDesktopReferenceJavascript[大本の番号]"></a>
    ##### JavaScript

    <a name="regularDesktopReferenceRuby[大本の番号]"></a>
    ##### Ruby

    <a name="regularDesktopReferencePhp[大本の番号]"></a>
    ##### PHP

    <a name="regularDesktopReferenceSql[大本の番号]"></a>
    ##### SQL
    ###### PostgreSQL
    ###### SQLite
    ###### Oracle Database
    ###### MySQL
    ###### Microsoft SQL Server
    ###### Sybase
    ###### Universe

    <a name="regularDesktopReferencePcrelib[大本の番号]"></a>
    ##### ライブラリ
    ###### PCREライブラリ
    ###### 鬼車ライブラリ
    ###### 鬼雲ライブラリ
    ###### re2ライブラリ
    ###### GNU Regexライブラリ
    ###### Boost.Regexライブラリ

</details>

<details><summary>正規表現利用事例用のひな形</summary>

上記のひな形での説明記載だけで足りない場合、以下の事例を用いる。  

    検索テキスト：
    ```txt
    [テキストを記載する。]
    ```

    正規表現(検索コマンド)：
    ```command
    [ここに正規表現のコマンドを記載する。]
    ```

    出力結果：
    ```output
    [ここに検索用の正規表現コマンドの実行結果を記載する。]
    ```

</details>

<details><summary>注意事項</summary>

### 注意4種類
※**注意1**  
**vim**は、_vi_ と区別せず、全て**Vim**用の正規表現を使う。  
要は、正規表現とは名ばかりで、実際は拡張正規表現を使うと言うこと。  

※**注意2**  
基本的な正規表現(のルール)は、  
1. 最早([最左](#regularLanguageGeneraltermLongestleftmost))のマッチが優先される。  
   最早って何？  
1. 標準の[量指定子](#regularLanguageGeneraltermQuantifier)は[欲張り](#regularLanguageGeneraltermLongestmatch)である。  

の2種類(ルール)で構成される。  

※**注意3**  
正規表現エンジンは、2種類存在する。  
* 決定性有限オートマトン  
  Deterministic Finite Automation：DFA  
  NFAに比べれば処理速度は速いが、機能制限がある。  
* 非決定性有限オートマトン  
  Nondeterministic Finite Automation：NFA  
  機能が豊富(文字列キャプチャ・前後読み・非欲張り型量指定子)。  
  NFAには2種類に分かれている。  
  * 従来型(traditional NFA)。  
    POSIX NFA以外のNFAベースの処理系を明示的に指す場合に利用する語。  
  * POSIX型。  

※**注意4**  
* DFAエンジン  
  最長最左のルールがある(上記注意2のルール1に"最長"のルールが追加される)。  
* 従来型NFAエンジン  
  欲張り型量指定子で文字列を探すが、失敗した場合、前回成功したマッチ文字列を採用する。  
  そのため、それより後ろに最長の文字列があった場合無視されることになる(上記注意2のルール1に"欲張り型量指定子の後ろに出てくる場合、最早最左のマッチが優先される"のルールが追加される)。
  最早って何？  
* POSIX NFAエンジン  
  基本は従来型のNFAと同じだが、違うのは"常に最長の選択肢を採用する"点にある。  

</details>

<a id="shoeisha9784798156422onebook"></a>
## 参考書籍(1冊目)。
書籍：[正規表現辞典 改訂新版](#shoeisha9784798156422contents)  
ISBN：978-4798156422  
ASIN：B07BPVNJCW  
著者：佐藤 竜一  
発行：2018/5/24 発売日  
出版社：翔泳社; 第1版  
関連先URL：<https://www.shoeisha.co.jp/book/detail/9784798156422>  
形式：単行本(ソフトカバー)  


<a id="oreilly9784873113593twobook"></a>
## 参考書籍(2冊目)。
書籍：[詳説 正規表現 第3版](#oreilly9784873113593contents)  
ISBN：978-4873113593  
ASIN：なし。  
著者：Jeffrey E.F. Friedl  
訳者：株式会社ロングテール  
訳者：長尾 高弘  
発行：2008/4/26 発売日  
出版社：オライリージャパン; 第3版  
関連先URL：<https://www.oreilly.co.jp/books/9784873113593/>  
形式：大型本  


<a id="algorithm"></a>
## アルゴリズム
正規表現を利用する上での心付け。  

### ファイル内の検索
コメント行や空行を無視することを優先した方が良い。  

<details><summary>Perl</summary>

Perlでのファイル読み込み時に、コメント行や空行を無視する方法。  

```Perl
while (<FILE>) {
	next if /^#/;
	next if /^\s*(#|$)/;
	chomp;
	say $_;
}
```

</details>

## 一般用語
以下、わざわざ詳細部分からタイトルを抜き出しているのだが、不要か？  

* 以下に詳しい(下記の詳細を開いておく必要がある)。  
  [マッチ(match)](#regularLanguageGeneraltermMatch)
  [最長一致(longest match)の考え方。](#regularLanguageGeneraltermLongestmatch)
  [バックトラック(backtrack)](#regularLanguageGeneraltermBacktrack)
  [ステート(state)](#regularLanguageGeneraltermState)
  [強欲(possessive)の考え方](#regularLanguageGeneraltermPossessive)
  [最短一致(shortest match)の考え方。](#regularLanguageGeneraltermShortestmatch)
  [アトミックなグループ(Atomic Grouping)](#regularLanguageGeneraltermAtomicgrouping)
  [最長最左(longest leftmost)](#regularLanguageGeneraltermLongestleftmost)
  [文字(character)](#regularLanguageGeneraltermCharacter)
  [図形文字](#regularLanguageGeneraltermCharacterGraphic)
  [制御文字](#regularLanguageGeneraltermCharacterControl)
  [文字列(string)](#regularLanguageGeneraltermString)
  [文字クラス(character class)](#regularLanguageGeneraltermCharacterclass)
  文字クラスでの否定
  文字クラスのショートカット。
  [文字クラスエスケープ(character class escape)](#regularLanguageGeneraltermCharacterclassescape)
  [ロカール(lacale)・ロケール](#regularLanguageGeneraltermLacale)
  [量指定子(quantifier)](#regularLanguageGeneraltermQuantifier)
  `?`
  `*`
  `+`
  `{指定回数}`
  `{最小出現回数,最大出現回数}`
  `{最小出現回数,}`
  `{,最大出現回数}`
  [POSIX文字クラス表現(POSIX character class expression)](#regularLanguageGeneraltermPosixcharacterclassexpression)
  [メタキャラクタ(metacharacter)](#regularLanguageGeneraltermMetacharacter)
  `.`
  `\`
  [閉包(closure)`*`](#regularLanguageGeneraltermClosure)
  [制御文字(control character)](#regularLanguageGeneraltermControlcharacter)
  [ダイアクリティカルマーク(diacritical marks)](#regularLanguageGeneraltermDiacriticalmarks)
  [等価クラス(equivalence class)](#regularLanguageGeneraltermEquivalenceclass)
  [部分正規表現(subexpression)](#regularLanguageGeneraltermSubexpression)
  [キャプチャ(capture)](#regularLanguageGeneraltermCapture)
  [クラスタ化(clustering)](#regularLanguageGeneraltermClustering)
  [グループ化構成体(grouping constructs)](#regularLanguageGeneraltermGroupingconstructs)
  [クロイスタ(cloister)](#regularLanguageGeneraltermCloister)
  [後方参照(backreference)](#regularLanguageGeneraltermBackreference)
  [ブラケット表現(bracket expression)](#regularLanguageGeneraltermBracketexpression)
  [マッチングリスト(matching list)](#regularLanguageGeneraltermMatchinglist)
  [非マッチングリスト(non-matching list)](#regularLanguageGeneraltermNonmatchinglist)
  [範囲指定表現(range expression)](#regularLanguageGeneraltermRangeexpression)
  [アンカー(anchor)境界](#regularLanguageGeneraltermAnchor)
  `^`
  `\A`
  `$`
  `\Z`
  `\z`
  `\b`
  `\<`
  `\B`
  `\>`
  `\G`
  `\b{X}`
  [エスケープ(escape)](#regularLanguageGeneraltermEscape)
  [オートマトン(automaton)](#regularLanguageGeneraltermAutomaton)
  [基本正規表現(basic regular expression：BRE)](#regularLanguageGeneraltermBasicregularexpression)
  [拡張正規表現(extended regular expression：ERE)](#regularLanguageGeneraltermExtendedregularexpression)
  [行終端子(line terminator)](#regularLanguageGeneraltermLineterminator)
  [空文字列(null string/empty string)](#regularLanguageGeneraltermNullstring)
  [繰り返し表現(interval expression)](#regularLanguageGeneraltermIntervalexpression)
  [先読み(lookahead)](#regularLanguageGeneraltermLookahead)
  [戻り読み(lookbehind)](#regularLanguageGeneraltermLookbehind)
  [前後読み(lookaround)](#regularLanguageGeneraltermLookaround)
  [修飾子(modifier)](#regularLanguageGeneraltermModifier)
  [照合要素(collating element)](#regularLanguageGeneraltermCollatingelement)
  [選択肢(alternation)もしくは代替(論理和)](#regularLanguageGeneraltermAlternation)
  [連接(concatenation)](#regularLanguageGeneraltermConcatenation)
  [方言](#regularLanguageGeneraltermDialect)

改行せずに1行にまとめたが、無駄なことをしているように感じている。  

<details><summary>一般用語(上記目次の詳細内容)</summary>

<a id="regularLanguageGeneraltermMatch"></a>
* マッチ  
  検索単語に一致していることを表すのだが、完全一致してるのではない(文字列の一部にマッチする)。  
  そのため、適切な日本語表現がないため、そのまま**マッチ**の文言を使うのが一般的になっている。  
  具体的なマッチとは、探したい文字列の中から正規表現を使った検索で見つける状態を表す。  
  正規表現を使うとは、[メタキャラクタ](#regularLanguageGeneraltermMetacharacter)を含む検索語で検索することなど。  

<a id="regularLanguageGeneraltermLongestmatch"></a>
* 最長一致の考え方。  
  閉包の`*`は、**先行する正規表現の0回以上の繰り返し**を意味する。  
  そして、最長一致(途中のマッチを気にせず、最長を採用)する結果を返す。  
  また、欲張り(greedy)または貪欲とも言う。  
  <a id="regularLanguageGeneraltermBacktrack"></a>
  * バックトラック  
    NFAを利用する場合に限って使われる技法。  
    処理中にマッチ失敗する場合、別の選択肢を選ぶために処理を後戻りさせること。  
    **abracadab**に対し、`.*ra`で検索を掛けた場合、`abra`がマッチする。  
    以下、流れ。  
    1. `abracadab`検索対象文。  
       `.*ra`検索語  
    1. abracadabから`.*`を検索した結果。  
    　　↓  
       abracadabがマッチする。  
    1. 次に、abracadabから`ra`を検索した結果。  
    　　↓  
       abraがマッチする。  
       本来であれば、マッチしないはずの文から`ra`を見つけ出せるのは、`.*`に対する`abracadab`から`ra`を探し出す必要があるため、最後の文字から切り捨てている。  
    これをバックトラック(後戻りした)と言う。  
    ※このバックトラック処理は、処理速度低下に起因する。  
  <a id="regularLanguageGeneraltermState"></a>
  * ステート  
    [バックトラック](#regularLanguageGeneraltermBacktrack)が可能になる目印を付けること。  
  <a id="regularLanguageGeneraltermPossessive"></a>
  * 強欲の考え方  
    バックトラックの無駄な発生を抑えるための記法(`*+`)を表す。  
    最長一致の原則に従ってマッチした場合、[ステート](#regularLanguageGeneraltermState)を破棄する。  
    1回目でマッチした場合、それ以降処理を続けずにステートを破棄すると言うことは、期待した結果が返ってこない可能性がある。  
    例えば、`abc9`の文字列から`.*+\d`で正規表現を掛けた場合、マッチに失敗する(強欲でなければ`.*\d`マッチする)。  

<a id="regularLanguageGeneraltermShortestmatch"></a>
* 最短一致の考え方("欲張りではない"・非欲張り・非貪欲)。  
  マッチする文字列候補への最も短い文字列にマッチすること。  
  また、無欲(reluctan)とも呼ぶ。  
  `?`は、**任意の文字の0個以上の連続**を意味する。  
  そして、最長一致(途中のマッチを気にせず、最長を採用)する結果を返す。  
  **abracadab**に対し、`.*?ra`で検索を掛けた場合、`abra`がマッチする。  
  以下、流れ。  
  1. `abracadab`検索対象文  
     `.*?ra`検索語。  
  1. aから`.*?は空文字でもマッチするため、いきなりra`を検索した結果。  
  　　↓  
     aを確認(比較)するが、マッチせず、失敗する。  
  1. 次の単語、abから`ra`を検索した結果。  
  　　↓  
     検索に失敗する。  
     そのため、次の単語を確認する。  
  1. 次に、abrから`ra`を検索した結果。  
  　　↓  
     検索に成功したが(?)、まだ足りないため、次の単語を確認する。  
     ※この順序を理解していないのだが、**ra**でひとかたまり？  
  1. 次に、abraから`ra`を検索した結果。  
  　　↓  
     成功した。  
     abraがマッチする。  
     不要最小の状態から徐々に必要なものに手を伸ばしていき、最終的に正規表現にマッチする。  

<details><summary>Perl言語での例</summary>

* 通常検索  
  `"exasperate" =~ /e(.*)e/`  
  `$1`には、"xasperat"が設定される。  

* 最短一致検索  
  `"exasperate" =~ /e(.*?)e/`  
  `$1`には、"xasp"が設定される。  
  後半の"rat"を探し出せないのは、最左最短規則に法っている。  
  そして、その規則は、Perl限定であり、他のプログラミング言語では最短のみが優先されることもある。  
  また、Perlで後半の"rat"を探す場合は、`/.*e(.*?)e/`とする。  


</details>

<a id="regularLanguageGeneraltermShortestmatch"></a>
以下、Perl限定か？
|マッチ回数|メタキャラクタ|
|----------|--------------|
|`??`|0回(意味が無い)|
|`*?`|0回以上、できるだけ少なく。|
|`+?`|1回以上、できるだけ少なく。|
|`{3,}?`|少なくとも3回、しかし、できるだけ少なく。|
|`{3,5}`|少なくとも3回、最高5回、しかし、できるだけ少なく。|
|`{3}?`|ちょうど3回。|

<a id="regularLanguageGeneraltermAtomicgrouping"></a>
* アトミックなグループ  
  バックトラックを発生させないための記法(`(?>パターン)`)を表す。  

<a id="regularLanguageGeneraltermLongestleftmost"></a>
* 最長最左  
  マッチ候補(検索語)が複数ある場合、最も長い文字列にマッチする(`int|inter|interger`の3種類であれば、`interger`に一致するのから探す)。

<a id="regularLanguageGeneraltermCharacter"></a>
* 文字  
  制御情報を表すために定義された記号。  
  以下、2種類を指す。  
  <a id="regularLanguageGeneraltermCharacterGraphic"></a>
  * 図形文字  
    英数字・日本語・各種記号など  
  <a id="regularLanguageGeneraltermCharacterControl"></a>
  * [制御文字](#regularLanguageGeneraltermControlcharacter)  
    改行・タブなど。  

<a id="regularLanguageGeneraltermString"></a>
* 文字列  
  0文字以上の文字の連続。  
  そのため、[制御文字](#regularLanguageGeneraltermCharacterControl)だけでも文字列という(印刷物には何も表示されないが文字列という)。  

<a id="regularLanguageGeneraltermCharacterclass"></a>
* 文字クラス  
  一般用語。  
  パターン内の1つの位置にマッチする文字集合のこと。  
  例）`[abcde]`であれば、**a**から**e**までのどれか1文字にマッチする。  
  別の書き方として、`[a-e]`でも同じ意味。  
  この場合、ハイフン記号にマッチしないため、マッチさせる場合は、`[a\-b]`・`[-abc]`・`[abc-]`のように、エスケープ・先頭・末尾にすること。  
  そして、`[.]`のドット記号は、ワイルドカードではなく、ドットそのものにヒットする。  
  他の特殊記号として、`[\n]`は改行、`[\t]`はタブを表す。  
  また、[ブラケット表現](#regularLanguageGeneraltermBracketexpression)のこと。  

  * 文字クラスでの否定  
    `[^a-z]`にて、先頭に`^`記号を付けた場合、否定になる。  
    今回の例で言えば、**a**から**z**以外の文字にヒットすることを意味する。  

  * 文字クラスのショートカット。  
    [文字クラスエスケープ](#regularLanguageGeneraltermCharacterclassescape)のこと。  

<a id="regularLanguageGeneraltermCharacterclassescape"></a>
* 文字クラスエスケープ  
  `\d`のように、特定の文字集合を表現する[メタキャラクタ](#regularLanguageGeneraltermMetacharacter)を総称する語。  
  ちなみに、`\d`は、0から9までの数字を表す(そして、`[\d\D]`は改行文字も含め、あらゆる文字にマッチする)。
  `\s`は、空白と見なされる文字を表す(そして、`[\s\S]`は改行文字も含め、あらゆる文字にマッチする)。  
  要は、ひとつの表現で複数の文字を指す。  

<a id="regularLanguageGeneraltermCharacterclassescapetable"></a>
以下、Perl限定か？
|ショートカット|マッチする|
|--------------|----------|
|`\d`|数字|
|`\D`|数字以外|
|`\s`|空白文字|
|`\S`|空白文字以外|
|`\h`|水平方向の空白文字(Perl-v5.10以降)|
|`\H`|水平方向の空白文字以外(Perl-v5.10以降)|
|`\v`|垂直方向の空白文字(Perl-v5.10以降)|
|`\V`|垂直方向の空白文字以外(Perl-v5.10以降)|
|`\R`|あらゆる種類の行末(Perl-v5.10以降)|
|`\w`|いわゆる「ワード」文字|
|`\W`|いわゆる「ワード」文字以外|
|`\n`|改行文字(厳密にはショートカットではない)|
|`\N`|改行文字以外(Perl-v5.18以降)|

<a id="regularLanguageGeneraltermCharacterclassescapeunicode"></a>
Unicode属性
|ショートカット|マッチする|
|--------------|----------|
|`\p{Space}`|あらゆる空白|
|`\p{Digit}`|あらゆる数字|Perl-v5.24では、550種類の文字にマッチする可能性があるそうだ。

<a id="regularLanguageGeneraltermLacale"></a>
* ロカール  
  言語及び文化的習慣(地域)に依存する特定の環境を示す概念。  
  文字・文字などの整列順序・日付・時刻・数値・通過書式など。  

<a id="regularLanguageGeneraltermQuantifier"></a>
* 量指定子  
  別名：繰り返し演算子  
  直前の文字・[メタキャラクタ](#regularLanguageGeneraltermMetacharacter)・[部分正規表現](#regularLanguageGeneraltermSubexpression)の繰り返し用[メタキャラクタ](#regularLanguageGeneraltermMetacharacter)のこと。  
  例えば、[`*`](#regularLanguageGeneraltermClosure)や`+`など。  
  また、単独で使われることはない。[atom](#regularLanguageGeneralTermsLanguageperlPriority)の直後に使われることで意味を成す。  
  * `?`：直前項目が0回または1回現れることを意味する(1回でもマッチした場合、それ以降検索せずに終わる)。  
  * `*`：直前項目が0回以上現れることを意味する(同じ項目である限りマッチし続ける)。  
  * `+`：直前項目が1回以上現れることを意味する(同じ項目である限りマッチし続ける)。  
  * `{指定回数}`：直前項目が指定回数現れることを意味する。  
  * `{最小出現回数,最大出現回数}`：直前項目が最小出現回数現れ、最大出現回数まで現れることを意味する(これを**汎用量指定子**と言う)。  
    例）`hoge{2,3}b`の場合、2個または3個の`e`にマッチすることを意味する(`hogeeb`・`hogeeeb`)。  
    また、この例で言えば、**hogeeeeb**にはマッチしないと言うこと(4つ出現しているため)。  
  * `{最小出現回数,}`：直前項目が最小として指定回数現れ、最高の出現は**上限なし**まで現れることを意味する。  
  * `{,最大出現回数}`：この書き方はPerl-v5.24に存在しない？  

この表必要か？  
|量指定子|必要最小数|マッチ思考の上限|意味|
|--------|----------|----------------|----|
|`?`|0|1|1回は認められるが、必須ではない(任意の1回)|
|`*`|0|無制限|無限に認められるが、必須ではない(いくつでも可)|
|`+`|1|無制限|無限に認められ、1回は必須(最低1回必要)|


<a id="regularLanguageGeneraltermPosixcharacterclassexpression"></a>
* POSIX文字クラス表現  
  **特定の文字クラスに含まれる文字**を表現するための記法。  
  `[:`と`:]`で括る。  
  また、POSIX文字クラスもしくはPOSIXブラケット表現とも言う。  

|クラス|意味|
|------|----|
|alnum|アルファベットと数字|
|alpha|アルファベット|
|blank|空白とタブ文字|
|cntrl|制御文字|
|digit|数字|
|graph|空白を除く表示可能文字|
|lower|小文字アルファベット|
|print|空白を含む表示可能文字|
|punct|アルファベットと数字を除く表示可能文字|
|space|空白|
|upper|大文字アルファベット|
|xdigit|16進数|

使用例）
`[:alnum:]`  


<details><summary>Perl言語専用</summary>

POSIX文字クラスを使う場合は、Perlのバージョン指定をすること。  
`use 5.6.0;`  

`^`を付けることで、このクラスを否定することもできる(Perl独自拡張)。  

|POSIX|クラシック|
|-----|----------|
|`[:^digit]`|`\D`|
|`[:^space]`|`\S`|
|`[:^word]`|`\w`|

Perlで使う場合、POSIXスタイルをPerlの文字クラスとして扱う必要がある。  
誤）
`/^[:digit:]$/`  
正）
`/^[[:digit:]]+$`  

</details>

<a id="regularLanguageGeneraltermMetacharacter"></a>
* メタキャラクタ  
  メタ文字・メタ文字列・メタシンボルとも言う。  
  特殊な意味を持つ文字を指す。  
  例えば、`*`は、直前の正規表現の0回以上の繰り返しを表し、`*`そのものを検索することはしない。  
  そのため、`*`を検索したい場合は、[エスケース](#regularLanguageGeneraltermEscape)させる必要があり、`\*`とする。  
  * `.`：改行文字を除く、あらゆる1個の文字にマッチする(ドットワイルドカード)。  
    ドットそのものにもヒットする(しかし、メタキャラクタであることを意識しておくこと)。  
    Perl-v5.12：`\N`の書き方もできる。  
  * `\`：バックスラッシュ記号もメタキャラクタのひとつ。  

<a id="regularLanguageGeneraltermClosure"></a>
* 閉包`*`  
  直前の正規表現の0回以上の繰り返しを表す(直前の正規表現が存在しない場合にもマッチする)。  
  例えば、`S*`は、`空文字列`・`S`・`SS`・`SSS`・`SSSSSSSSSS`などにマッチする。  
  クリーネ閉包(Kleene closure)とも言う。  

<a id="regularLanguageGeneraltermControlcharacter"></a>
* 制御文字  
  特別な文字。  
  改行・Tab文字など。  
  一般的には、ASCIIの0x00から0x1Fに定義されている32文字とDEL(0x7F)を指すが、他にもある。  

<a id="regularLanguageGeneraltermDiacriticalmarks"></a>
* ダイアクリティカルマーク  
  アクセント記号のこと。  
  通常の文字との合字で表現する。  
  `ä`・`℅`・`©`など。  
  ちなみに、Vimエディタでこれを入力する場合は、[`CTRL-K {char1} [char2]`](https://vim-jp.org/vimdoc-ja/digraph.html#digraphs)をする。  

<a id="regularLanguageGeneraltermEquivalenceclass"></a>
* 等価クラス  
  特定の[ロカール](#regularLanguageGeneraltermLacale)にて、等価だと見なされている複数の文字を包括すること。  
  例えば、`é`・`ë`・`è`・`ę`・`ē`などは、`e`単体で、先の文字5種類の文字と見なす。  

<a id="regularLanguageGeneraltermSubexpression"></a>
* 部分正規表現  
  検索語をひとくくりの単位として扱うこと。  
  `(`と`)`で括る。  
  部分正規表現には、[量指定子](#regularLanguageGeneraltermQuantifier)を適用できる。  
  また、[キャプチャ](#regularLanguageGeneraltermCapture)用途に使うため、部分正規表現定義用に、`(?:`・`)`で括らせる処理系もある。  
  グルーピング(grouping)とも言う？  

  <a id="regularLanguageGeneraltermCapture"></a>
  * キャプチャ  
    [部分正規表現](#regularLanguageGeneraltermSubexpression)にマッチした文字列を一時的に記憶しておくこと。  
    Perlの場合、`/(\d+)/`の場合は1桁以上の数字にマッチしたひとくくりのものが`$1`にキャプチャされている。
    しかし、`/(\d)+/`の場合は、1桁以上の数字にマッチした最後の数字を`$1`にキャプチャする。  
    * [後方参照](#regularLanguageGeneraltermBackreference)にて取り出せる。  

  <a id="regularLanguageGeneraltermClustering"></a>
  * クラスタ化  
    `(`と`)`でくくり、ひとつの単位として扱うこと。  
    しかし、キャプチャをしないため、[後方参照](#regularLanguageGeneraltermBackreference)対象外になる。  
    Perlでは、`(?:パターン)`と記述することで、キャプチャ(例えば`\1`)から外れる。  

  <a id="regularLanguageGeneraltermGroupingconstructs"></a>
  * グループ化構成体  
    [クラスタ化](#regularLanguageGeneraltermClustering)に使う記号の総称。  
    `(`と`)`でくくり、ひとつの単位として扱う場合、[キャプチャ](#regularLanguageGeneraltermCapture)対象になるが、それ以外でのグループ化構成体によってクラスタ化されたものはキャプチャ対象外になる。  

  <a id="regularLanguageGeneraltermCloister"></a>
  * クロイスタ  
    [グループ化構成体](#regularLanguageGeneraltermGroupingconstructs)のひとつ。  
    一時的に処理モードを変更するために利用する。  
    パターン修飾子(`/i`・`/m`・`/s`・`/x`)をパターンの一部だけに適用する手法。  
    Perlでの様式：`((?パターン修飾子)パターン)`キャプチャあり。  
    Perlでの様式：`(?パターン修飾子:パターン)`キャプチャ無し。  
    Perlでの使用例）`(?i:パターン)`大小文字区別なしパターンになる。  
    その適用を無効化するにはマイナス記号を付ける。  
    Perlでの使用例）`m/abc(?-i:GhI)def/i`大小文字区別なしパターンになる。  
    **abc**と**def**は、大小文字区別なしだが、**GhI**は、この文字のみ一致することを表す。  

  <a id="regularLanguageGeneraltermBackreference"></a>
  * 後方参照  
    [部分正規表現](#regularLanguageGeneraltermSubexpression)が[キャプチャ](#regularLanguageGeneraltermCapture)した内容を後から取り出して利用する記法。  
    例えば、`\数字`で取り出すのが習わしだが、他の取り出し方もある(数字部分はグルーピングした左側から1ずつ増えていく)。  
    例）"hello"の文字列に`e(l)\1o`とした場合、**ello**としてヒットする。  
    Perl-v5.10：`\g{N}`(Nは後方参照番号)の書き方もできる。  
    誤字？P155で、「`\k<label>`は、\g{label}とは少し違います。」とあるのに、なぜかその違いを説明していない(それとも`\g{N}`との違いを説明したかった？)。  
    また、前方参照とも言う。  

<a id="regularLanguageGeneraltermBracketexpression"></a>
* ブラケット表現  
  これは、POSIX用語。一般用語は、[文字クラス](#regularLanguageGeneraltermCharacterclass)と言う。  
  **複数の文字からなる集合のうちのいずれか**という概念を表現する記法(`[]`に囲まれた文字)。  
  例えば、`[ab]`の場合、`a`または`b`のどちらかの文字を検索語として使う。  
  また、`[a-d]`の場合は、`a`から`d`までのアルファベット1文字が検索対象にあることを期待する検索語となる。  
  <a id="regularLanguageGeneraltermMatchinglist"></a>
  * マッチングリスト  
    ブラケット表現をしたときの[否定](#regularLanguageGeneraltermNonmatchinglist)(`[^パターン]`)をしていない文字のこと。  
  <a id="regularLanguageGeneraltermNonmatchinglist"></a>
  * 非マッチングリスト  
    ブラケット表現をしたときの文字を否定する(`[]`ブラケット表現の先頭に`^`記号を付ける`[^]`)。  
    例えば、`[^ab]`の場合は、`a`もしくは`b`以外の文字にマッチする文字を探すことを表す。  
    `^`をブラケット表現として検索語にする場合は、先頭以外に配置する(`[a^]`など：この場合は`a`または`^`にマッチすることを期待する)。  
  <a id="regularLanguageGeneraltermRangeexpression"></a>
  * 範囲指定表現  
    ブラケット表現での範囲指定のこと。  
    `[a-d]`であれば、`a`から`d`までを表している範囲を指す。  

<a id="regularLanguageGeneraltermAnchor"></a>
* アンカー  
  正規表現がマッチする位置を特定の場所に固定するために用いる[メタキャラクタ](#regularLanguageGeneraltermMetacharacter)の総称。  
  その特定場所を固定するのは強制であるため、ゼロ幅言明(もしくは、ゼロ幅アサーション：zero-width assertion)とも言う。  
  また、そのマッチするのは、特定の条件だが、文字にはマッチしない。  
  例えば、Perlの`\A(文字列先頭)`で検索する場合、先頭文字にマッチしなければ、次の文字を検索しないことを意味する。  

<details><summary>独自に作られているため、個別に調べた方が良い</summary>

  * アンカー  
    * `^`  
      行終端子の直後にマッチ(`\A`とは異なる)または文字列の先頭。  
      vimでは、`\_^`と言うのも存在する。  
      Perlなどのマルチライン`/m`修飾子を付けた場合、`\A`と同じ働きとして改行直後にマッチする。  
    * `\A`  
      文字列の先頭にのみマッチ。  
      使える処理系は少ない。  
    * `$`  
      行終端子の直前にマッチ(`\z`・`\Z`とは異なる)または文字列の末尾。  
      vimでは、`\_$`と言うのも存在する。  
      Perlなどのマルチライン`/m`修飾子を付けた場合、`\Z`と同じ働きとして改行文字直前にマッチする。  
    * `\Z`  
      文字列の末尾あるいは文字列の末尾の行終端子の直前にマッチ。  
      使える処理系は少ない。  
    * `\z`  
      文字列の末尾にマッチ(改行すらない末尾)。  
      使える処理系は少ない。  
    * `\b`  
      単語の境界にマッチ。  
      使える処理系は少ない。  
      `\w\W`の組み合わせと同じ(この場合は、単語終了境界になり、`\W\w`の場合は単語開始境界になる)。  
    * `\<`  
      単語の先頭にマッチ。  
      使える処理系は少ない。  
    * `\B`  
      単語の境界以外にマッチ。  
      使える処理系は少ない。  
    * `\>`  
      単語の末尾にマッチ。  
      使える処理系は少ない。  
    * `\G`  
      前回のマッチの末尾にマッチ。  
      使える処理系は少ない。  
    * `\b{X}`  
      Unicodeの書記素クラスタ／単語／文の境界にマッチ。  
      使える処理系は少ない。  
      基本的には、Perlだけ？  

以下、Perl限定。
|ワード境界|意味|対応バージョン|
|----------|----|--------------|
|`\b`|通常のワード境界|Perl|
|`\b{wb}`|ワード境界(Unicodeに基づく)|Perl-v5.22|
|`\b{sb}`|文の境界|Perl-v5.22|
|`\b{lb}`|行の境界(扱いが難しい)|Perl-v5.24|

Perlでの検索(`m//`)時に、`/m`修飾子を付ける(`m//m`)ことで、文字列中の行頭や改行文字にもマッチする。  
付けなければ、文字列全体(ファイル内)の1カ所のみヒットする(先頭と末尾のみヒットする・行頭や改行はヒットしない)。  

Perlの場合、変数をダブルクォーテーションで囲った場合、変数展開が行われる。  
```Perl
$hoge = "hello";
m/$hoge$/;
```
そのため、上記のプログラムがあった場合、`$hoge`の変数展開が行われ、その次に`hello$`の検索が行われる。  
※注意事項として、変数展開させる正規表現の場合、処理速度が低下する。  

</details>

<a id="regularLanguageGeneraltermAssertion"></a>
* アサーション(assertion)  
  1文字幅も0文字幅のこともアサーションと呼ぶのだが、基本的にはゼロ幅を指すことが多い。  
  幅が0ではないものを[atom](#regularLanguageGeneralTermsLanguageperlPriority)と呼ぶ。  

<a id="regularLanguageGeneraltermEscape"></a>
* エスケープ  
  [メタキャラクタ](#regularLanguageGeneraltermMetacharacter)の特殊な意味を打ち消す。  
  `*`を`*`として検索したい場合は、`\*`とする。  
  また、`\\*`とした場合、`*`はエスケープされておらず、2つ目の`\`がエスケープされていることになる。  

<a id="regularLanguageGeneraltermAutomaton"></a>
* オートマトン  
  計算を行う仕組みに対する数学的なモデルの総称。  
  例えば、自動販売機で例えられることが多く、自動販売機をオートマトンとした場合、硬貨が入力として扱われ、自動販売機は受け取った硬貨をもとに内部状態を遷移(金額に応じて販売可能な飲み物などを販売可能に)していく。  

<a id="regularLanguageGeneraltermBasicregularexpression"></a>
* 基本正規表現  
  POSIX定義の2種類のうちの1つ(単純正規表現は含まない)。  
  利用可能なツールは、`sed`・`grep`・`vi`・`ed`などがある。  
  例えば、特徴として、[部分正規表現](#regularLanguageGeneraltermSubexpression)を使う括弧の前に[エスケープ](#regularLanguageGeneraltermEscape)記号を付ける必要がある。  
  `(`と`)`ではなく、`\(`と`\)`を使う。  

<a id="regularLanguageGeneraltermExtendedregularexpression"></a>
* 拡張正規表現  
  POSIX定義の2種類のうちの1つ(単純正規表現は含まない)。  
  利用可能なツールは、`awk`・`egrep`などがある。  
  そして、[基本正規表現](#regularLanguageGeneraltermBasicregularexpression)の上位互換ではない。  
  そのため、基本正規表現で定義されている一部の[メタキャラクタ](#regularLanguageGeneraltermMetacharacter)が利用できない。  

POSIXの正規表現規定の概要。
|正規表現の機能|基本正規表現|拡張正規表現|
|--------------|------------|------------|
|`.`・`^`・`$`・`[・・・]`・`[^・・・]`|ある|ある|
|"任意子の"量指定子|`*`|`*`|
|`+`・`?`量指定子|ない|`+`・`?`|
|範囲|`\{min, max\}`|`{min, max}`|
|グループ化|`\(・・・\)`|`(・・・)`|
|`()`に対する量指定子の適用|ある|ある|
|後方参照|`\1〜\9`|ない|
|選択|ない|ある|

<a id="regularLanguageGeneraltermLineterminator"></a>
* 行終端子  
  行の末尾を表す文字。  
  基本的には改行を利用するが、復帰・NEL・垂直タブ・フォームフィードなどもある。  

<a id="regularLanguageGeneraltermNullstring"></a>
* 空文字列  
  文字が1文字も存在しない文字列のこと。  
  0文字の連続を示す概念。  
  連続の空文字列は1つの空文字列と見なす。  
  また、空文字という概念はない。  

<a id="regularLanguageGeneraltermIntervalexpression"></a>
* 繰り返し表現  
  繰り返す数を明示する記法。  
  `{繰り返しの最小回数, 繰り返しの最大回数}`などのように使う。  

<a id="regularLanguageGeneraltermLookahead"></a>
* 先読み  
  指定位置から文字が読まれる方向に文字列を読み進めることによって、指定された正規表現にマッチする文字列が見つかるかどうかを調べること。  

<a id="regularLanguageGeneraltermLookbehind"></a>
* 戻り読み  
  指定位置から文字が読まれる方向とは逆方向に文字列を読み進めることによって、指定された正規表現にマッチする文字列が見つかるかどうかを調べること。  
  また、後読みとも言う。  

<a id="regularLanguageGeneraltermLookaround"></a>
* 前後読み  
  [先読み](#regularLanguageGeneraltermLookahead)と[戻り読み](#regularLanguageGeneraltermLookbehind)の総称。  

|読み方|正規表現|囲まれている部分式が成功する条件|
|------|--------|--------------------------------|
|肯定の後読み|`(?<=パターン)`|部分式が**左側**にマッチ**する**ときに成功する|
|否定の後読み|`(?<!パターン)`|部分式が**左側**にマッチ**しない**ときに成功する|
|肯定の先読み|`(?=パターン)`|部分式が**右側**にマッチ**する**ときに成功する|
|否定の先読み|`(?!パターン)`|部分式が**右側**にマッチ**しない**ときに成功する|

<a id="regularLanguageGeneraltermModifier"></a>
* 修飾子  
  別名：**[マッチ修飾子](#regularLanguageGeneralTermsLanguageperl)[(Perl)](#regularLanguageGeneralTermsLanguageperlmatchmodifier)**・**パターン修飾子(PHP)**・フラグ(flag)とも呼ぶ。  
  正規表現での特定記号を特定処理として利用すること。  
  例えば、s修飾子によって`.`が行終端子にマッチさせるようにすることなど。  

<a id="regularLanguageGeneraltermCollatingelement"></a>
* 照合要素  
  POSIXで定義されている概念で、単一の実態としてみなされてる2文字以上の文字の連続。  
  個々の照合要素を示すのが照合シンボルになる。  
  照合シンボルは[ロカール](#regularLanguageGeneraltermLacale)によって定義される。  

<a id="regularLanguageGeneraltermAlternation"></a>
* 選択肢  
  **2つ以上の正規表現のいずれか**を表現する概念。  
  例えば、`A|B`であれば、AまたはBを表す。  
  ※Aにマッチしなければ、Bにマッチする可能性を探す。  
  また、限定した選択をする場合は、[括弧](#regularLanguageGeneraltermSubexpression)を使い、[グループ化](#regularLanguageGeneraltermClustering)する。  
  例）`aB|Cd`の場合、**aB**か**Cd**のどちらかにヒットする。  
  `a(B|C)d`の場合、**aBd**か**aCd**のどちらかにヒットする。  
  例）`( +|\t+)`の場合、全てがTAB文字か、もしくは全てが半角スペースのどちらかにヒットする(要は、混在させることが出来ない)。  
  ※この場合は、丸括弧により[キャプチャ](#regularLanguageGeneraltermCapture)されている。  
  それを避ける場合は、[クラスタ化](#regularLanguageGeneraltermClustering)により、防ぐことができる(`(?: +|\t+)`)。  
  注意すべきことは、[部分正規表現](#regularLanguageGeneraltermSubexpression)の有無により結果が変わることにある。  
  例えば、`/^cat|dog|cow$/`の場合、先頭に**cat**があり、末尾に**cow**があることを検索するだろうが、本来求めたのは違うだろう。  
  求めた選択肢は、`/^(cat|dog|cow)$/`であり、1行の中に、**cat**・**dog**・**cow**のどれかがあることだろう。  
  選択肢のなかで空でも構わない。  
  例えば、次の3種類は全て同じ意味になる(ただし、キャプチャは異なる)。  
  `abc(def(g|)|)`・`abc(def(g?)?)`・`abc(defg?)?`  
  `?`を使う場合、マッチしないときの`$1`などは未定義になる。  
  `|`を使う場合、マッチしないときの`$1`などは空文字列になる。  

<a id="regularLanguageGeneraltermConcatenation"></a>
* 連接  
  1つの正規表現を複数繋げたもの。  

<a id="regularLanguageGeneraltermDialect"></a>
* 方言  
  プログラミング言語によって正規表現の利用法が変わること。  

</details>

<a id="regularLanguageGeneralTermsLanguage"></a>
### 言語別(利用での前提条件)用語など。
Perl互換の正規表現搭載の検索エンジンは、完全互換ではない(Perlの正規表現は、Perl独特の言語仕様に結びついているため、完全互換性を持つことは不可能)。  

* 言語別  
  * [Vimエディタ](#regularLanguageGeneralTermsLanguagevim)  
  * [秀丸エディタ](#regularLanguageGeneralTermsLanguageHidemaru)  
  * [サクラエディタ](#regularLanguageGeneralTermsLanguagesakura)  
  * [grep](#regularLanguageGeneralTermsLanguagegrep)  
  * [Go](#regularLanguageGeneralTermsLanguagego)  
  * [AutoHotKey](#regularLanguageGeneralTermsLanguageAutoHotKey)  
  * [egrep](#regularLanguageGeneralTermsLanguageegrep)  
  * [Perl](#regularLanguageGeneralTermsLanguageperl)  
  * [C#](#regularLanguageGeneralTermsLanguagecsharp)  
  * [Python](#regularLanguageGeneralTermsLanguagepython)  
  * [Java](#regularLanguageGeneralTermsLanguagejava)  
  * [C++](#regularLanguageGeneralTermsLanguagecplusplus)  
  * [sed](#regularLanguageGeneralTermsLanguagesed)  
  * [awk](#regularLanguageGeneralTermsLanguageawk)  
  * [VBA](#regularLanguageGeneralTermsLanguagevba)  
  * [.Net](#regularLanguageGeneralTermsLanguagedotnet)  
  * [JavaScript](#regularLanguageGeneralTermsLanguagejavaScript)  
  * [ライブラリ](#regularLanguageGeneralTermsLanguagelib)  


<a id="regularLanguageGeneralTermsLanguagevim"></a>
#### [Vimエディタ](https://www.vim.org)
無茶苦茶使うエディタなので、必然的に正規表現も使う。  
標準検索の規格構文はPOSIXに近いそうだ。  
そして、私の使い方は検索時に`/\v`(very magic検索)としているため、なかなか今回の実利用を記録に残せないかも・・・そのやり方で残せば良いのだが・・・。  

* 検索オプション  
  * Perl検索に近づける(`/\v`very magic検索)。  
  * テキストそのものの検索(`/\V`very nomagic検索)。  
  * 本来のvim検索(`/`magic検索)。  
  * vi挙動検索(nomagic検索)。  

<details><summary>Vim検索の細かい話</summary>

* [検索種類](https://vim-jp.org/vimdoc-ja/pattern.html#/magic)。  
  * Perl(Python・Ruby)検索に近づける。  
    `/\v`(verymagic検索)  
    **_**・**大小文字のアルファベット(`A〜Z`・`a〜z`)**・**0〜9**を除く全ての文字が特殊な意味を持つ。  
    ※現時点では**#**記号は特殊な意味を持っていないが、将来的には持つかもしれない。  
    ※検索単語に`/`が含まれていた場合、[エスケープ](#regularLanguageGeneralTermsLanguagevimEscape)する必要がある(それ以降の文字を検索対象から外すため)。  
    括弧付での論理和検索する場合(例`/\v%(And|D)rew`)括弧内だけの置換をしないように、`%`記号を括弧前に付けた方が良い。  
  * テキストそのものの検索。  
    `/\V`(verynomagic検索)  
    ※基本的には、見たままを検索する(以下例外)。  
    ※検索単語にバックスラッシュ`\`・終端文字(通常`/`・`?`)が含まれていた場合、[エスケープ](#regularLanguageGeneralTermsLanguagevimEscape)する必要がある。  
  * 本来のvim検索。  
    `/`  
  * vi挙動検索。  
    `/\m`(magic検索)  
    `/\M`(nomagic検索・非推奨)  

* 検索オプション。  
  * 大小文字区別なし。  
    `:set ignorecase`  
  * 大小文字区別あり。  
    `:set noignorecase`  
  * 小文字入力を大小文字区別なしで検索する。  
    `:set smartcase`  
    大文字を検索値に含めた場合、大小文字を区別して検索する。  
    以下は、検索語末尾に付けることでも有効化する。  
    * `\c`  
      大小文字区別なし検索。  
    * `\C`  
      大小文字区別あり検索。  
  * 折り返し検索なし。  
    `:set nowrapscan`  

<a id="regularLanguageGeneralTermsLanguagevimEscape"></a>
* 検索時の文字をエスケープする。  
  前提：検索単語をレジスタに保存しておく必要がある(`"ayw`：aレジスタにカーソル単語をヤンク)。  
  実際の準備コマンド：`\V`からの`/\V`が検索用プロンプト。  
  そのコマンド中：`/\V<C-r>=escape(@a, getcmdtype().'\')`  
  こうすることで`\`にバックスラッシュがなされるようだ。  
  以下のプラグイン導入で、選択範囲を検索対象にすることができた。  
  `*`・`#`での検索：<https://github.com/nelstrom/vim-visual-star-search>  


</details>

※[VimScript](https://vim-jp.org/vimdoc-ja/usr_41.html)は、[別項目](../vimScript言語/README.md)として作る。  

<a id="regularLanguageGeneralTermsLanguageHidemaru"></a>
#### [秀丸エディタ](https://hide.maruo.co.jp/software/hidemaru.html)
ネットでの最新版？  
[正規表現（Ver8.97対応版）](https://help.maruo.co.jp/hidemaru/html/190_CmdSearch_Regular.html)  

> 正規表現は、外部のDLL（プログラム）によって実現されています。  
> 秀丸エディタでは、「HmJre.dll」と「Jre32.dll」と言うDLLが標準でインストールされ標準の設定では、「HmJre.dll」を使用するように設定されています。  
> 正規表現検索で使用するＤＬＬの変更は、[動作環境]-[環境]で行うことができます。  
> Hmjre.dllの詳細な仕様については、HmJre.dllのヘルプを参照してください。  

このDLLさえ変更すれば、Perl互換の正規表現を使えると言うことかな。  

<https://www.arimac.com>  
> 秀丸エディタでPerl互換の正規表現が使えるようにします。  

<a id="regularLanguageGeneralTermsLanguagesakura"></a>
#### [サクラエディタ](https://sakura-editor.github.io)
秀丸エディタと違い、[鬼車(bregonig.dll)](https://sakura-editor.github.io/help/HLP000006.html)を利用しているため、Perl5互換の正規表現で検索できる。  


<a id="regularLanguageGeneralTermsLanguagegrep"></a>
#### grep
<https://docs.oracle.com/cd/E19683-01/816-3986/6ma7sa297/index.html>  
> grep ユーティリティは、テキストファイルにおいてパターンを検索し、そのパターンを含むすべての行を出力します。grep は、単純な非決定性アルゴリズムを使用します。  


<a id="regularLanguageGeneralTermsLanguagego"></a>
#### [Go](https://golang.org)
[正規表現処理](https://go言語.com/pkg/regexp/)は劇的に遅いらしい。  
そのため、正規表現を使わない設計にするのが吉らしい。  

<a id="regularLanguageGeneralTermsLanguageAutoHotKey"></a>
#### [AutoHotKey](https://www.autohotkey.com)
利用関数名：
`RegExMatch()`  

構文：
`RegExMatch(Target, Pattern [, OutputVar = "", StartingPos = 1])`  


たまに使うツールのため、記録には残したいが、、、記録に残す前に解決してそのままにしそうだ。  

<a id="regularLanguageGeneralTermsLanguageegrep"></a>
#### egrep
grepの上位版。  
そして、grepとは互換性がない。  
そのため、拡張正規表現と表現するようになった。  

<a id="regularLanguageGeneralTermsLanguageperl"></a>
#### [Perl](https://www.perl.org)
このプログラミング言語が世の中の基準になったと言っても過言ではないほどの[正規表現](https://perldoc.jp/docs/perl/5.16.1/perlreref.pod)が多岐に渡る表現を行える(日本語がおかしい)。  

<a id="regularLanguageGeneralTermsLanguageperlDetailedreg"></a>
<details><summary>Perl言語での正規表現の細かい話</summary>

Perlでの検索様式：
`m//`  

正規表現の勉強で、Perl言語から目を背けることが出来ない。  
その理由は、「Perl互換正規表現(Perl-Compatible Regular Expression：PCRE)」を謳っている正規表現検索ツールが出回っているせいでもあるからだ。  

Perl言語の場合、パターン部分が空で検索する場合に、前回成功した検索(`m//`・`s///`)のパターンを再利用する。  

<a id="regularLanguageGeneralTermsLanguageperlDetailedreglist"></a>
<details><summary>Perl言語での`m//`をリストコンテキストで使う</summary>

[split](#regularLanguageGeneralTermsLanguageperlDetailedsplit)では、不要文字を区切りパターンとして置換作業を実施した。  
今回は、必要な部分をパターン化して置換する。  

```Perl
# 以下、通常利用の検索結果をスカラーコンテキストに代入している。
my $hoge = "Hello World boo!";
my ($hello, $world, $boo) = $hoge =~ m/(\S+) (\S+) (\S+)/;
say "$hello, $world, $boo";	# Hello, World, boo!

# 以下、区切り作業処理開始。
my $hoge = "3 shout 8 word ⇒ Hello World, asakuno!";
#	以下、リストコンテキストとして値の代入。
my @words = $hoge =~ m/([a-z]+)/ig;
#	以下、リストコンテキストとして表示。
say "@words";	# shout word Hello World asakuno
```

</details>

* Perl独自の検索結果の特殊変数  
  サンプルあり(ファイル名：[Perl独自の特殊変数(正規表現用のみ).pl](Perl言語の勉強(正規表現利用に限る)/Perl独自の特殊変数(正規表現用のみ).pl))。  
  * `$&`  
    マッチした文字列。  
    プログラム内で処理速度が落ちる(微々たるもの？)。  
    Perl-v5.10以降：`/p`修飾子を使った場合、`${^MATCH}`で代替可能(処理速度低下は、これを使った正規表現のみに限定される)。  
  * ``` $` ```  
    マッチした部分より前にある文字列。  
    プログラム内で処理速度が落ちる(微々たるもの？)。  
    Perl-v5.10以降：`/p`修飾子を使った場合、`${^PREMATCH}`で代替可能(処理速度低下は、これを使った正規表現のみに限定される)。  
  * `$'`  
    マッチした部分より後にある文字列。  
    プログラム内で処理速度が落ちる(微々たるもの？)。  
    Perl-v5.10以降：`/p`修飾子を使った場合、`${^POSTMATCH}`で代替可能(処理速度低下は、これを使った正規表現のみに限定される)。  
  * `$1`(下記の"`\g{N}`(後方参照)"参照)  
    最初の括弧で囲まれた部分パターンにマッチした文字列(`$2$3・・・`順次括弧2番目括弧3番目になる)。  
    別名：括弧変数というらしい。  
  * `$+`  
    マッチした最後の部分文字列。  
  * `@-`  
    全体マッチと部分マッチの開始オフセットのリスト。  
  * `@+`  
    対応する終了オフセットのリスト。  
リストコンテキストで使用した場合、パターンの丸括弧部分パターンにマッチする文字列で構成されるリスト($1, $2, $3, ・・・)を返す。  


<a id="regularLanguageGeneralTermsLanguageperlDetailedregBackreference"></a>
* Perl-v5.10では、`\1`(後方参照)を使わずに、8進エスケープと区別するために、[`\g{N}`](#regularLanguageGeneralTermsLanguageperlcapture)を使う(`N`は後方参照番号)。  
  書き方によっては、`{}`記号を省略できるが、わざわざ省略する必要はないだろう。  
  また、`\g{-N}`のように、負の数をしていできる(要は、相対後方参照：relative back reference)。  
  相対後方参照を使う場合は、後方参照より柔軟性が高い。  
* Perl-v5.10では、`\R`の文字クラスエスケープは、行末(linebreak)にマッチする(要は、OSなどの種類を問わずに、ありとあらゆる改行にマッチする)。  
* Perl-v5.12では、`.`(ドットワイルドカード)を使わずに**改行文字以外の任意の文字**を表す別の方法に[`\N`](#regularLanguageGeneraltermCharacterclassescapetable)が使える。  

<a id="regularLanguageGeneralTermsLanguageperlDetailedregnote1"></a>
**注意事項1**：
[文字クラスのショートカット](#regularLanguageGeneraltermCharacterclass)での`\w`ショートカットは、ワード文字を表すが、この場合の**ワード文字**と言うのは、Perlの変数やサブルーチンの名前に使える文字を表している。  
Perlを主体で考える必要があると言うこと。  

Perlでは、Unicode属性に、Unicodeコンソーシアムが決めた属性名を用いているが、少しの例外がある。  
そして、独自の属性名を追加している。  

<a id="regularLanguageGeneralTermsLanguageperlDetailedregnote2"></a>
**注意事項2**：
[キャプチャ](#regularLanguageGeneraltermCapture)の有効期限は、次のパターンマッチが成功するまで残る。  
そのため、マッチに失敗した直後でキャプチャを使う場合は、前のマッチ結果を使うことになる。  
それを防ぐためには、失敗した場合は、処理を飛ばすなどの対処が必要になる。  

<a id="regularLanguageGeneralTermsLanguageperlmatchmodifier"></a>
マッチ修飾子とは、パターンの動作を変えるもしくはマッチ演算子の動作を変える。  
様式：`m/パターン/マッチ修飾子`  
マッチ修飾子の展開：`m/パターン/[g[c]][i][m][s][o][x][n]`  

* マッチ修飾子(match modifier)  
  正確には、**パターンマッチ修飾子**という。  
  また、スラッシュの後に付けることから **/o演算子** (スラッシュオー演算子・slash oh modifier)とも言う。
  * `[g[c]]`  
    * `g`：可能なだけマッチを行う。  
      スカラーコンテキストで`g`を用いた場合、繰り返し構文の条件式として使用できる。  
      マッチに失敗した場合、条件式がリセットされる。  
    * `c`：`g`と供に使い、継続検索を行う。  
      スカラーコンテキストで用いた場合、マッチに失敗した場合も処理を[位置ポイント](#regularLanguageGeneraltermAnchor)リセットしない。  
  * `[i]`(insensitive)  
    大小文字区別なし検索をする。  
  * `[m]`  
    文字列を複数行として扱う。  
    `^`と`$`を文字列中の改行文字とマッチさせることになる。  
    サンプルを用意したが、よく分からず([Perl独自の行頭と行末アンカー.pl](Perl言語の勉強(正規表現利用に限る)/Perl独自の行頭と行末アンカー.pl))。  
  * `[s]`(single line)  
    文字列を単独行として扱う。  
    `.`は文字列中の改行文字とマッチすることになる。  
    改行文字以外にマッチさせる場合は`[^\n]`もしくは`\N`を使う。  
  * `[o]`  
    1回だけ変数展開を行う。  
    そのため、実行中に変数値が変わった場合も新しい値を使わずに実行を継続することになる。  
    (通常[デリミタ](#regularLanguageGeneraltermNotes)としてシングルクォーテーションで囲むことを例外とすれば、パターン演算子の評価都度変数展開が行われる。)  
  * `[x]`(extend)  
    空白(もしくはタブ)とコメントを許可する。  
    空白などをマッチさせる場合はエスケープさせる必要がある(`\ `・`\t`など)。
    しかし、空白などをマッチさせる最善は`\s`を使う。  
    ブロック記号と同じ文字をコメントに付けてはならない(`m{}`の場合、コメント部分に`}`を付けてはならない)。  
    Perlの場合の`\`解釈：`m/(.*?) \t+ (.*?)/x`の場合の`\t+`は問題なく機能する。しかし、`$tab="\t+"; m/(.*?) $tab (.*?)/x;`は失敗する。  
    `/o`のように、[デリミタ](#regularLanguageGeneraltermNotes)としてシングルクォーテーションで囲むことにより解決する。  
  * `[n]`  
    グループ化する括弧をキャプチャせずに検索する。  
    Perl-v5.22以降で利用可能。  
    誤字？P153の`\n`により、「キャプチャしないグループに変換します。」とあるのに、わざわざキャプチャしない(`(?:〜)`)状態にしている(どっちが有効になっているか分からない)。  

* 文字の解釈フラグ  
  文字クラスの扱いに、以下のフラグを付けることで、それぞれの扱い方が変わる。  
  * `/a`  
    ASCIIコードの文字を使う。  
    例）`/\w+/a`
    **A-Z, a-z, 0-9, _**  
    Unicodeを検索対象にする場合、大文字を小文字に変換するときに[挙動](https://perldoc.jp/docs/perl/5.14.1/perlunicode.pod#The32Unicode32Bug)が変わる。  
    `/a`は文字クラスショートカットに影響させるだけだが、`/aa`の場合は、大小文字の変換をASCIIに対してのみ行う。  
  * `/u`  
    Unicodeの文字を使う。  
    例）`/\w+/u`
    **任意のUnicodeワード文字**  
  * `/l`  
    ロケールに従う。  
    例）`/\w+/l`
    **ASCIIバージョンに、ロケールからのワード文字を追加**  

<a id="regularLanguageGeneralTermsLanguageperlPriority"></a>
* 正規表現の優先順位  
  1. グループ化とキャプチャに使われる括弧`()`。  
  1. 量指定子`*`・`+`・`?`・`{X,Y}`・`{X,}`・`{X}`。  
  1. アンカーと並び(sequence)。  
     アンカー：`\A`・`\Z`・`\z`・`^`・`$`・`\b`・`\B`など。  
     並び：文字を並べた状態。  
  1. 選択肢`|`。  
  1. アトム(atom)。  
     文字幅が0でないものを表す。  
     例えば、個々の文字`a`とか`b`とか・文字クラス`[abc]`など・後方参照`\1`や`\g{2}`などなど。  
     逆に、[アンカー](#regularLanguageGeneraltermAnchor)である`\b`は幅が0であるため、アトムとは言わない。  
     このアトムについては、結構細かい[ルール](https://perldoc.jp/docs/perl/5.10.1/perlre.pod)があるようだ。  

<a id="regularLanguageGeneralTermsLanguageperlcapture"></a>
* キャプチャ  
  [スコープ](#regularLanguageGeneralTermsLanguageperlDetailedregnote2)あり。  
  * 通常キャプチャの[利用方法](#regularLanguageGeneralTermsLanguageperlDetailedregBackreference)(`$1`・`$2`・`$3`・・・)。  
    例）`m/(one) (two) (three)/`⇒`say $1 $2 $3`⇒"one two three"  
    検索内での使い回す例：後方参照例）`m/(one) (two) (\1)/`⇒`say $1 $2 $3`⇒"one two one"  
    検索内での使い回す例：後方参照例）`m/(one) (two) (\g{1})/`⇒`say $1 $2 $3`⇒"one two one"  
  * キャプチャ無しのグループ化。  
    ※グルーピングだけする(それ以外で使えないように破棄する)。  
    例）`m/(?:one) (two) (three)/`⇒`say $1 $2 $3`⇒"two three (`$3`は存在しない)"  
    検索内での使い回す例：後方参照例）"キャプチャなし"のため、使い回せない。  
  * 名前付きキャプチャ  
    `$1`・`$2`・`$3`・・・の数字での参照ではなく、名前で使い回すことにする。  
    キャプチャ様式(グループ化に名前付け)：`(?<名前>パターン)`  
    後方参照様式(検索内で使い回す)：`\1`・`\2`・`\3`・・・  
    後方参照様式(検索内で使い回す)：`\g{1}`・`\g{2}`・`\g{3}`・・・(`\g{N}`の`N`は負の数により、相対後方参照にできる)  
    ラベル付き後方参照様式(検索内で使い回す)：`\g{ラベル名}`  
    ラベル付き後方参照様式(検索内で使い回す)：`\k<ラベル名>`  
    Python式キャプチャ様式(グループ化に名前付け)：`(?P<ラベル名>パターン)`  
    Python式ラベル付き後方参照様式(検索内で使い回す)：`(?P=ラベル名)`  
    当たり前だが、括弧で囲まれている必要がある(グループ化が必須条件のため)。  
    例）`m/(?<one>hoge) (?<boo>bar) (?<name>asakuno)/`⇒`say $+{boo} $+{name} $+{one};`⇒"bar asakuno hoge"  
    検索内での使い回す例：後方参照例）`m/(?<one>hoge) (?<boo>bar) (\g{one})/`⇒`say $1 $2 $3;`⇒"hoge bar hoge"  
    検索内での使い回す例：後方参照さらに別の例）`m/(?<one>hoge) (?<boo>bar) \k<one>/`  
    検索内での使い回す例：後方参照さらにさらに別の例）`m/(?P<one>hoge) (?P=one)/`  

* **今後の発展方法**  
  * 『[続・初めてのPerl 改訂第2版](https://www.oreilly.co.jp/books/9784873116280/)』に詳しいようだ。  
    これの前の版なら持っている(第7版で紹介しているのが、私の持っている前の阪なんだが、、、どういうこと!?)。  
    そんなことより、勉強のために泣く泣く『[初めてのPerl 第7版](https://www.oreilly.co.jp/books/9784873118246/)』を買ったばかりだというのに、外国では『[第8版](https://www.oreilly.com/library/view/learning-perl-8th/9781492094944/)』が出るとか・・・もう少し待ったら日本語版で買えたとか？  
    それは無いか。第8版の出版が今年の8月って・・・第7版が2016年発売で、日本語版発売が3年ほどあとだと思えば、第8版の日本語版は2023年かその翌年ぐらいだろう。  
    Perlを本格的に勉強しないとは言え、買っただけの価値はありそうだから由としよう。  
    ついでに見つけた『[Learning Perl 6](https://www.oreilly.com/library/view/learning-perl-6/9781491977675/):2018年出版（日本語で言えば、初めてのPerl6）と言ったところだろうか』それが発売されているが、日本語版はないようだから、よほど[Perl6](https://raku.org)は人気が無いのだろうな(そもそも別言語だからな)。  
    日本語版を出すのであれば、いい加減デスクトップリファレンスも新しくして欲しい。[第3版](https://www.oreilly.co.jp/BOOK/p5dkr3/index.htm)がPerl-v5.6って・・・。  
  * [パターンテストプログラム](https://www.learning-perl.com/downloads_page/)  
    以下のプログラムでは、パターンをいくつかの文字列に対してマッチさせて、どの文字列のどこにマッチするかを調べるのに使う。  

```Perl
#!/usr/bin/perl
while (<>) {	# take one input line at a time
	chomp;
	if (/YOUR_PATTERN_GOES_HERE/) {
		print "Matched: |$`<$&>$'|\n";	# the special match vars
	} else {
		print "No match: |$_|\n";
	}
}
```
例）`/match/`指定での**beforematchafter**に対しての結果が`|before<match>after|`として表示される。  

</details>

<a id="regularLanguageGeneralTermsLanguageperlDetailedrep"></a>
<details><summary>Perl言語での置換の細かい話</summary>

Perlでの置換様式：
`s///`  
これを置換演算子(substitution operator)と言うそうだ。  

置換も検索同様に結合演算子(`=~`)を使う。  
`$hoge =~ s/boo/test/`  
※変数`$hoge`の値が置換される。  

以下、上記で言う`$hoge`の値を保持した状態の置換方法。
```Perl
my $hoge = "Hello World.";
my $backup = $hoge;
$backup =~ s/Hello/boo/;
```

上記を1行にまとめる方法。
```Perl
my $hoge = "Hello World.";
(my $backup = $hoge) =~ s/Hello/boo/;
```
※`$backup`に置換後の結果が代入される。  

以下の`/r`修飾子を使うことで、括弧不要で記述できる。
```Perl
use v5.14;
my $hoge = "Hello World.";
my $backup = $hoge =~ s/Hello/boo/r;
```
※`$backup`に置換後の結果が代入される。  


* 置換修飾子
  [マッチ修飾子](#regularLanguageGeneralTermsLanguageperlDetailedreg)も一部使える(以下)。  
  `/i`
  `/x`
  `/m`
  `/s`が使える。  
  `/o`が使えない(代わりに、メタクォートを使う)。  
  * `/g`  
    出現パターン全てを置き換える。  
  * `/e`  
    置換文字列をPerl式として評価する。  
    例）`s/(\d+)/$1 * 2/;`これは、数字(例えば42)を"42 * 2"に置き換える処理。  
    例）`s/(\d+)/$1 * 2/e;`これは、数字(例えば42)を"84"に置き換える処理。  
  * `/ee`(複数個のeを使う)  
    以下、どちらも同じ結果を得る。  
    例）`s/パターン/eval(コード)/e;`コードを実行する。  
    例）`s/パターン/コード/ee;`コードを実行する。  
  * `/r`  
    Perl-v5.14：非破壊置換として、元の変数値を保持する。  

  <a id="regularLanguageGeneraltermMetaquart"></a>
* メタクォート  
  [メタキャラクタ](#regularLanguageGeneraltermMetacharacter)を無効化する。  
  使用例）使用前：`s/\(\(\(hoge/boo/`⇒使用後：`s/\Q(((hoge/boo/`  
  ※これは、3つの`(`を普通の文字として検索対象にしている。  
  [論理和(`|`)](#regularLanguageGeneraltermAlternation)のために[グルーピング](#regularLanguageGeneraltermClustering)する場合の使用例）`s/\Q(((\E(hoge|boo)/bar/`  
  ※これは、3つの`(`を普通の文字として(メタキャラクタ無効化として)検索対象にしており、`\E`にて無効化を解除し、その後の括弧をメタキャラクタとしてグループ化(`(hoge|boo)`)でまとめている。  
  ※**hoge**または**boo**だった場合、**bar**に置き換える処理(当然単語の前に3つの`(`があることを前提にしている)。  

  <a id="regularLanguageGeneraltermNotes"></a>
* 注意事項  
  * `/g`グローバル置換  
    置換処理を複数行に分ける方が、グローバル置換より処理速度は早い。  
  * 対記号(デリミタ)  
    * 対にならない記号の場合は、それを3個使う。  
      例）`s///`⇒`s#パターン#置換テキスト#`  
    * 対になる記号の場合は、それぞれを囲む。  
      例）`s{パターン}<置換テキスト>`・`s[パターン]#置換テキスト#`  
      この場合のデリミタは、間にスペースがあっても問題ない(`s(パターン)    @置き換えテキスト@`)。
    * `'`をデリミタに使う(`m'パターン'`)。  
      変数展開を行わず、6種類の変換エスケープを行わない。  
      使い方が分からない。  
    * `?`をデリミタに使う(`m?パターン?`)。  
      1度だけのマッチを行う。  
      使い方が分からない。  
  * 非破壊置換  
    上記で述べた通りだが、`(my $置換結果格納用変数名 = $元の変数名) =~ s/パターン/置換テキスト/`は、置換結果が**置換結果格納用変数名**に格納される。  
    括弧なしがよければ、`/r`修飾子を使う。  
    例）`my $置換結果格納用変数名 = $元の変数名 =~ s/パターン/置換テキスト/r`  

</details>

<a id="regularLanguageGeneralTermsLanguageperlDetailedsplit"></a>
<details><summary>Perl言語でのsplit演算子について</summary>

**split**は、タブ区切りのデータ・コロン区切りのデータ・空白文字区切りのデータ・その他で区切られたデータの区切り方を正規表現(単純なもの)で指定する。  
また、例外として、カンマ区切りのCSVファイルを除く(単純置き換えしか出来ないため、CSVなどの複雑な区切りは対応できない)。  

様式：
`my @配列名 = split /区切りパターン/, $文字列変数名;`  
※"区切りパターン"が、本来欲しいデータ出端に不要な文字を指定する場所であることを意識する。  

<a id="regularLanguageGeneralTermsLanguageperlDetailedsplitnote1"></a>
**注意事項1**：
単純な使い方に限る。  
それは、区切りパターン内で[キャプチャ](#regularLanguageGeneraltermCapture)をしないこと。  
使ってしまった場合、「セパレータ保存モード」になってしまうため(どういう意味？)。  
もし、使いたい場合は、キャプチャしないグルーピング(`(?:パターン)`)を活用すること。  

</details>

<a id="regularLanguageGeneralTermsLanguageperlDetailedjoinfunk"></a>
<details><summary>Perl言語でのjoin関数について</summary>

パターンは使わない。  
しかし、[split](#regularLanguageGeneralTermsLanguageperlDetailedsplit)とは逆の処理をする。  

様式：
`my $戻り値用の変数名 = join $つなぎ文字用変数名, @配列名(もしくはリスト);`  

<a id="regularLanguageGeneralTermsLanguageperlDetailedjoinfunknote1"></a>
**注意事項1**：
**$つなぎ文字用変数名**は、文字列であって、パターンでは無いことに注意する。  
配列内容(もしくはリスト)をつなぐだけなので、先頭や末尾の要素には効果が無い(要は、リスト要素の個数より1つ少なくなる)。  


</details>

<a id="regularLanguageGeneralTermsLanguageperlDetailedfilechange"></a>
<details><summary>Perl言語でのファイル変更の細かい話</summary>

以下、引数にファイルを渡し、そのファイル内の日付を当日に変更する。

    chomp(my $date = `date`);
    say $date;
    
    # 以下の変数に値がある場合、引数に与えられたファイルに指定した拡張子を付けてバックアップする。
    $^I = ".bak";
    
    # <>は、ダイヤモンド演算子と言い、ファイルの自動オープン及び自動クローズをする。
    #	また、ファイルを与えられない場合、標準入力を読み取る。
    while (<>){
    	s/\ADate:.*/Date: $date/;
    	print;
    }
※日付部分が"Date:"で始まっている必要がある。

以下、1行プログラム。
```Perl
$perl -p -i.bak -w -e 's/Date:.*/Date: chomp(localtime)/' hoge*.md
```
* `$perl `以降の意味。  
  * `-p`  
    `while (<>) { print; }`のこと(それがオプション`-p`に納められている)。  
    `-n`オプションでは、`print`がない状態以外は同じ。  
  * `-i.bak`  
    `$^I = ".bak"`のこと。  
    `-i`だけにした場合、バックアップファイルを生成しない。  
  * `-w`  
    警告表示を有効化する。  
  * `-e`  
    この後ろに続くコードを実行するという意味。  
    `-e 'say hoge;' -e 'say boo'`などのように、複数行の処理が必要な場合、`-e`を複数に分ける。  
    ※複数使う場合、`;`は、最後の処理のみ省略できる。  
    * `'s/〜/〜/'`  
      処理内容なので、処理したいことを指定する。  
  * `hoge*.md`  
    ファイルだが、グロブ指定で、この名前に一致するファイルのみを処理する。  
    正確に言えば、このファイル名が`@ARGV`に与えられ、処理される。  
  * 以下、一連のプログラムをプログラムファイルに書き出した内容とする。  

```Perl
#!/usr/bin/perl -w

$^I = ".bak";

while (<>) {
	s/Date:.*/Date: chomp(localtime)/;
	print;
}
```

以下、実行結果。
```terminal
$ ll
total 16
-rw-r--r--  1 asakunotomohiro  staff   50  9  7 14:59 hoge20210907.md
$ cat hoge20210907.md	←☆今回置換対象のファイル。
Date: ほげ。
Date: 2021/09/07
date: 2021/09/07
$ perl -p -i.bak -w -e 's/Date:.*/Date: chomp(localtime)/' hoge*.md	←☆コマンド実施。
$ ll
total 24
-rw-r--r--  1 asakunotomohiro  staff   63  9  7 15:00 hoge20210907.md	←☆置換後のファイル名。
-rw-r--r--  1 asakunotomohiro  staff   50  9  7 14:59 hoge20210907.md.bak	←☆原本。
$ cat hoge20210907.md	←☆意図していない結果が出てきた。
Date: chomp(localtime)
Date: chomp(localtime)
date: 2021/09/07
$ cat hoge20210907.md.bak	←☆原本として何も変更されていない。
Date: ほげ。
Date: 2021/09/07
date: 2021/09/07
$
```

以下、`-e`を2つにして日付を取得した。
```Perl
$ ll
total 8
-rw-r--r--  1 asakunotomohiro  staff  41  9 10 00:43 hoge20210907.md
$ cat hoge20210907.md
Date: ほげ
Date: hoge
date: 2021/09/09
$ perl -p -i -w -e 'chomp(my $date = localtime);' -e 's/Date:.*/Date: $date/' hoge*.md	←☆処理部分を複数に分けた。
$ ll
total 8
-rw-r--r--  1 asakunotomohiro  staff  79  9 10 00:43 hoge20210907.md
$ cat hoge20210907.md	←☆意図した結果になった。
Date: Fri Sep 10 00:43:33 2021
Date: Fri Sep 10 00:43:33 2021
date: 2021/09/09
$
```

通常の`date`コマンドが使えない。
```Perl
$ perl -p -w -e 'chomp(my $date = `date`);' -e 's/Date:.*/Date: $date/' hoge*.md	←☆`記号が意図しない挙動をした。
Date: 2021年 9月10日 金曜日 00時44分52秒 JST
Date: 2021年 9月10日 金曜日 00時44分52秒 JST
date: 2021/09/09
$ cat hoge20210907.md	←☆そのため、ファイル内容が変わっていない。
Date: Fri Sep 10 00:43:33 2021
Date: Fri Sep 10 00:43:33 2021
date: 2021/09/09
$
$ perl -p -w -e 'chomp(my $date = \`date\`);' -e 's/Date:.*/Date: $date/' hoge*.md	←☆どうやってエスケープする？
Can't find string terminator "`" anywhere before EOF at -e line 1.
$ perl -p -w -e 'chomp(my $date = ``date``);' -e 's/Date:.*/Date: $date/' hoge*.md	←☆どうやってエスケープする？
Bareword found where operator expected at -e line 1, near "``date"
	(Missing operator before date?)
Unquoted string "date" may clash with future reserved word at -e line 1.
Backticks found where operator expected at -e line 1, near "date``"
syntax error at -e line 1, near "``date"
Execution of -e aborted due to compilation errors.
$
```

エラーは出なくなったが、ファイル内を書き換えてくれない。
```terminal
$ perl -p -e 'chomp(my $today = `date`);' -e 's/Date:.*/Date: $today/g;' hoge*.md
Date: 2021年 9月10日 金曜日 01時21分45秒 JST
Date: 2021年 9月10日 金曜日 01時21分45秒 JST
date: 2021/09/09
$ cat hoge20210907.md
Date: Fri Sep 10 00:43:33 2021
Date: Fri Sep 10 00:43:33 2021
date: 2021/09/09
$
```
置換後の結果は出力されているが、ファイルに書き込んでくれなければ意味が無い。  

全く分からない。
```terminal
$ perl -e 'chomp(my $today = `date`);' -e 's/Date:.*/Date: $today/g;' hoge*.md > 20210910.txt
$ ll
total 8
-rw-r--r--  1 asakunotomohiro  staff   0  9 10 01:27 20210910.txt
-rw-r--r--  1 asakunotomohiro  staff  79  9 10 00:43 hoge20210907.md
$ cat 20210910.txt
$ cat hoge20210907.md
Date: Fri Sep 10 00:43:33 2021
Date: Fri Sep 10 00:43:33 2021
date: 2021/09/09
$
```

できたぞ!?
```terminal
$ cat hoge20210907.md
Date: hogehoge
Date: booboo
date: 2021/09/09
$ perl -pi -e 'chomp(my $today = `date`);' -e 's/Date:.*/Date: $today/g;' hoge*.md
$ cat hoge20210907.md
Date: 2021年 9月10日 金曜日 01時31分44秒 JST
Date: 2021年 9月10日 金曜日 01時31分44秒 JST
date: 2021/09/09
$
```
オプション`p`と`i`を追加したことで何とかなった。  
前にやったときは反応が無かったため、間違ったオプションを付けたと思ったのに・・・。

オプション`l`を付けることで改行削除をしてくれるようだが、コマンド結果に対しては自動処理してくれないのか・・・空行の行末削除しても意味ないってことか・・・。
```terminal
$ perl -pli -e 'my $today = `date`; s/Date:.*/Date: $today/g;' hoge*.md
$ cat hoge20210907.md
Date: 2021年 9月10日 金曜日 01時33分40秒 JST

Date: 2021年 9月10日 金曜日 01時33分40秒 JST

date: 2021/09/09
$
```

保険のために付けておいた方が良いだろうな・・・。
```terminal
$ cat hoge20210907.md
Date: hoge
Date: boo
date: 2021/09/09
$ perl -pi -e 'chomp(my $today = `date`); s/Date:.*/Date: $today/g;' hoge*.md
$ cat hoge20210907.md
Date: 2021年 9月10日 金曜日 01時36分17秒 JST
Date: 2021年 9月10日 金曜日 01時36分17秒 JST
date: 2021/09/09
$
```

</details>

Perlによる正規表現の利用様式：
`m/パターン/`  
これを**パターンマッチ演算子**(pattern match operator)と言う。  
`/`記号で検索する場合は、`m`を省略し、`/パターン/`で検索できる。  
パターンに **/** 記号を含む場合は、ブロック記号(ここでは`/`)を変更するのが一般的だろう。  
例えば、`m{http://}`とした場合、わざわざ **//** をエスケープせずに書けるため、煩わしさがないだけでなく、保守しやすくなる。  
逆に、対になっているブロック記号の場合は、パターンでの記号を気にしなくて構わない。  
例えば、`m{.*{abc}.*}`などは記号を気にせずに使える。  
また、**<>** は、パターン記号でないため、`m<abc?>def>`の組み合わせが考えられるため、意図しない結果が出てくる(対策としてはエスケープするか、違うブロック記号を使う)。  

<a id="regularLanguageGeneralTermsLanguageperlDetailedconversionoperator"></a>
<details><summary>Perl言語での文字置き換え(`tr///変換演算子`)の細かい話</summary>

正規表現に全く無関係の演算子で有名な変換演算子もここで説明する。  
様式：
`tr/検索語/置き換え語/修飾子`  

Perlでのダブルクォーテーションで囲った変数は、変数展開をするのだが、この演算子ではその効果は無い。  
純粋に文字の置き換えだけを行うため、正規表現を全く使わずに文字を検索する。  
また、変数値を使う場合は、パターン結合演算子(`=~`)もしくは、それの非定型である二項演算子(`!~`)の左辺に変数を置けば良い。  
例）
`$hoge =~ tr/boo/hoge/`  
※"boo"を"hoge"に置き換える。  
また、検索語や置き換え語に変数を使いたい場合`eval "tr/$検索語用変数名/$置き換え語用変数名/"`とする。  

* 様式の詳細  
  * 検索語  
    しつこいようだが、正規表現でのパターンとは違い、単語そのもの。  
  * 置き換え語  
    検索語に一致した単語を置き換える単語。  
  * 修飾子  
    * `/c`(complement)  
      "検索語"に含まれない単語を探す。  
    * `/d`(delete)  
      "検索語"を置き換えられない場合、置き換えられない単語を削除する。  
    * `/s`(squash)  
      複数の置き換え語になった場合、それを1つにする。  

<a id="regularLanguageGeneralTermsLanguageperlDetailedconversionoperatornote1"></a>
**注意事項1**：
大文字を小文字に変換もしくはその逆をこの演算子で行ってはならない。  
理由は、[ロカール](#regularLanguageGeneraltermLacale)や[Unicode](#regularLanguageGeneralTermsLanguageperlmatchmodifier)の文字に配慮していないからだ。  

</details>

<a id="regularLanguageGeneralTermsLanguagecsharp"></a>
#### [C#](https://docs.microsoft.com/ja-jp/dotnet/csharp/)
Microsoft社が出している言語なので、独特の方言がありそうだが、どうだろうか。  

<a id="regularLanguageGeneralTermsLanguagepython"></a>
#### [Python](https://www.python.jp)
[正規表現操作](https://docs.python.org/ja/3/library/re.html?highlight=regular)ね・・・。  

<a id="regularLanguageGeneralTermsLanguagejava"></a>
#### [Java](https://www.oracle.com/jp/java/)
正規表現を使う場合、
`import java.util.regex.Pattern;`
と言うクラスの`matches`静的メソッドを利用する。  

<a id="regularLanguageGeneralTermsLanguagecplusplus"></a>
#### [C++](https://cpprefjp.github.io)
[正規表現](https://cpprefjp.github.io/reference/regex.html)を使う場合、
`#include <regex>`
の標準ライブラリ(`<regex>`ヘッダファイル)の読み込み(インクルード)が必要になる。  

<a id="regularLanguageGeneralTermsLanguagesed"></a>
#### [sed](https://docs.oracle.com/cd/E19683-01/817-7410/6mmnue1cm/index.html)

<a id="regularLanguageGeneralTermsLanguageawk"></a>
#### [awk](http://www.kt.rim.or.jp/%7Ekbk/gawk-30/gawk_toc.html)
Linuxとか触らないのに、[正規表現](http://www.kt.rim.or.jp/%7Ekbk/gawk-30/gawk_5.html#SEC25)まで手を出す必要は無いよね。  
sedにも言えることだけど。  

<a id="regularLanguageGeneralTermsLanguagevba"></a>
#### [VBA](https://docs.microsoft.com/en-us/openspecs/microsoft_general_purpose_programming_languages/ms-vbal/d5418146-0bd2-45eb-9c7a-fd9502722c74?redirectedfrom=MSDN)
公式ページが英語版しかない。  

<a id="regularLanguageGeneralTermsLanguagedotnet"></a>
#### [.Net](https://docs.microsoft.com/ja-jp/dotnet/standard/base-types/regular-expressions)
この.netを基準にC#の正規表現は動いているのか!?  

<a id="regularLanguageGeneralTermsLanguagejavaScript"></a>
#### [JavaScript](#https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Regular_Expressions#working_with_regular_expressions)
構文：
`str.match(regexp)`  

以下、[モジラサンプル](#https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/match)。
```javascript
const paragraph = 'The quick brown fox jumps over the lazy dog. It barked.';
const regex = /[A-Z]/g;
const found = paragraph.match(regex);

console.log(found);
// expected output: Array ["T", "I"]
```

<a id="regularLanguageGeneralTermsLanguagelib"></a>
#### ライブラリ
どのようなライブラリを使うか分からないが、とりあえず、ライブラリと名の付くものを集めてみた。  

##### 鬼車ライブラリ
ライブラリと名の付くもののひとつとして鬼車がある。  
上記通りにここにまとめたのだが、この鬼車を使うツールは、サクラエディタぐらいかな・・・と・・・。  



---
<!-- 目次部分(リンクになるところ) -->
<a id="shoeisha9784798156422contents"></a>
## [正規表現辞典 改訂新版-目次](#shoeisha9784798156422)
1. [INTRODUCTION](#regularDesktopReference1000001)
   1. [正規表現とは何か](#regularDesktopReference1010100)  
   1. [正規表現の用途](#regularDesktopReference1010200)  
   1. [正規表現をサポートする処理系](#regularDesktopReference1010300)  
   1. [正規表現の歴史](#regularDesktopReference1010400)  
   1. [正規表現の背景](#regularDesktopReference1010500)  
   1. [正規表現と文字コード](#regularDesktopReference1010600)  
   1. [正規表現用語リファレンス](#regularDesktopReference1010700)  

1. [処理系リファレンス](#regularDesktopReference2000001)  
   1. [grep / egrep](#regularDesktopReference2020100)  
   1. [文字列を検索する](#regularDesktopReference2020101)  
   1. [sed](#regularDesktopReference2020200)  
   1. [処理対象行を指定する](#regularDesktopReference2020201)  
   1. [指定した文字列を置換する（s コマンド）](#regularDesktopReference2020202)  
   1. [awk](#regularDesktopReference2020300)  
   1. [指定した文字列を置換する](#regularDesktopReference2020301)  
   1. [文字列に対するマッチを行う](#regularDesktopReference2020302)  
   1. [処理対象レコードを指定する](#regularDesktopReference2020303)  
   1. [vim](#regularDesktopReference2020400)  
   1. [文字列を検索する](#regularDesktopReference2020401)  
   1. [文字列を置換する](#regularDesktopReference2020402)  
   1. [Perl](#regularDesktopReference2020500)  
   1. [文字列に対するマッチを行う](#regularDesktopReference2020501)  
   1. [正規表現オペランド / オブジェクトを作成](#regularDesktopReference2020502)  
   1. [文字列を置換する](#regularDesktopReference2020503)  
   1. [PHP](#regularDesktopReference2020600)  
   1. [文字列を検索する](#regularDesktopReference2020601)  
   1. [配列から文字列を検索する](#regularDesktopReference2020602)  
   1. [正規表現全体をエスケープする](#regularDesktopReference2020603)  
   1. [文字列を置換する](#regularDesktopReference2020604)  
   1. [Java](#regularDesktopReference2020700)  
   1. [正規表現オブジェクトを生成する](#regularDesktopReference2020701)  
   1. [文字列に対するマッチを行う](#regularDesktopReference2020702)  
   1. [マッチした内容を取り出す](#regularDesktopReference2020703)  
   1. [文字列の置換を行う](#regularDesktopReference2020704)  
   1. [JavaScript](#regularDesktopReference2020800)  
   1. [RegExp オブジェクトの生成](#regularDesktopReference2020801)  
   1. [文字列に対するマッチを行う](#regularDesktopReference2020802)  
   1. [文字列の置換を行う](#regularDesktopReference2020803)  
   1. [Python](#regularDesktopReference2020900)  
   1. [正規表現オブジェクトを生成する](#regularDesktopReference2020901)  
   1. [文字列に対するマッチを行う](#regularDesktopReference2020902)  
   1. [文字列の置換を行う](#regularDesktopReference2020903)  
   1. [.NET](#regularDesktopReference2021000)  
   1. [正規表現オブジェクトを生成する](#regularDesktopReference2021001)  
   1. [文字列に対するマッチを行う](#regularDesktopReference2021002)  
   1. [文字列の置換を行う](#regularDesktopReference2021003)  

1. [メタキャラクタリファレンス](#regularDesktopReference3000001)
   1. [基本正規表現](#regularDesktopReference3030100)  
   1. [x 「その文字」自身にマッチ](#regularDesktopReference3030101)  
   1. [\ メタキャラクタの持つ特別な意味を失わせる](#regularDesktopReference3030102)  
   1. [. 任意の1文字にマッチ](#regularDesktopReference3030103)  
   1. [[xyz] 指定された文字の中のいずれかにマッチ](#regularDesktopReference3030104)  
   1. [(pattern)、\(pattern\) 部分正規表現のグルーピング](#regularDesktopReference3030105)  
   1. [\* 直前の正規表現と0回以上一致](#regularDesktopReference3030106)  
   1. [{min,max}、\{min,max\} 直前の正規表現と指定回数一致](#regularDesktopReference3030107)  
   1. [$ 文字列の末尾、または行終端子の直前にマッチ(行末ではない？)](#regularDesktopReference3030108)  
   1. [\^ 文字列の先頭、または行終端子の直後にマッチ](#regularDesktopReference3030109)  
   1. [\n キャプチャ済みの部分正規表現に対する後方参照](#regularDesktopReference3030110)  
   1. [[:..:] POSIX文字クラス表現](#regularDesktopReference3030111)  
   1. [[.ll.] 指定した照合要素にマッチ](#regularDesktopReference3030112)  
   1. [[=e=] 指定した等価クラスに含まれる文字にマッチ](#regularDesktopReference3030113)  
   1. [拡張正規表現](#regularDesktopReference3030200)  
   1. [x¦y、x\¦y 正規表現xまたはyにマッチ](#regularDesktopReference3030201)  
   1. [+、\+ 直前の正規表現と1回以上一致](#regularDesktopReference3030202)  
   1. [?、\?、\= 直前の正規表現と0回または1回一致](#regularDesktopReference3030203)  
   1. [文字クラスエスケープ](#regularDesktopReference3030300)  
   1. [\d、\D 任意の数字にマッチ / 数字以外の任意の1 字にマッチ](#regularDesktopReference3030301)  
   1. [\s、\S 任意の空白にマッチ / 空白以外の任意の文字にマッチ](#regularDesktopReference3030302)  
   1. [\w、\W 任意の単語構成文字にマッチ / 単語構成文字以外の任意の文字にマッチ](#regularDesktopReference3030303)  
   1. [v、\V 任意の垂直方向の空白にマッチ / 垂直方向の空白以外の任意の1 字にマッチ](#regularDesktopReference3030304)  
   1. [\h、\H 任意の水平方向の空白にマッチ / 水平方向の空白以外の任意の1 字にマッチ](#regularDesktopReference3030305)  
   1. [制御文字とUnicode](#regularDesktopReference3030400)  
   1. [\n、\a、\b、\e、\f、\r、\t 各種の制御文字にマッチ](#regularDesktopReference3030401)  
   1. [\cx xで指定した制御文字にマッチ](#regularDesktopReference3030402)  
   1. [\nnn、\onnn nnnに指定した8進表現で示される文字にマッチ](#regularDesktopReference3030403)  
   1. [\xnn nに指定した16進表現で示される文字にマッチ](#regularDesktopReference3030404)  
   1. [\unnnn、\x{n} nに指定したコードポイントで表現される文字にマッチ](#regularDesktopReference3030405)  
   1. [\p{...}、\P{...} Unicodeプロパティに基づく条件に合致する文字にマッチ](#regularDesktopReference3030406)  
   1. [\N{...} 正式なUnicode文字名で表現される文字にマッチ](#regularDesktopReference3030407)  
   1. [\x Unicodeの書記素クラスタにマッチ](#regularDesktopReference3030408)  
   1. [特殊な量指定子](#regularDesktopReference3030500)  
   1. [\*?、\{-} 直前の正規表現と0回以上一致（最短一致）](#regularDesktopReference3030501)  
   1. [{min,max}?、\{-min,max} 直前の正規表現と指定回数一致（最短一致）](#regularDesktopReference3030502)  
   1. [+? 直前の正規表現と1回以上一致（最短一致）](#regularDesktopReference3030503)  
   1. [?? 直前の正規表現と0回または1回一致（最短一致）](#regularDesktopReference3030504)  
   1. [\*+ 直前の正規表現と0回以上一致（強欲）](#regularDesktopReference3030505)  
   1. [{min,max}+ 直前の正規表現と指定回数一致（強欲）](#regularDesktopReference3030506)  
   1. [++ 直前の正規表現と1回以上一致（強欲）](#regularDesktopReference3030507)  
   1. [?+ 直前の正規表現と0回または1回一致（強欲）](#regularDesktopReference3030508)  
   1. [アンカー](#regularDesktopReference3030600)  
   1. [\b、\B 単語の境界にマッチ / 単語の境界以外にマッチ](#regularDesktopReference3030601)  
   1. [\<、\> 単語の先頭にマッチ / 単語の末尾にマッチ](#regularDesktopReference3030602)  
   1. [\A 文字列の先頭にマッチ](#regularDesktopReference3030603)  
   1. [\Z 文字列の末尾、あるいは文字列の末尾の行終端子の直前にマッチ](#regularDesktopReference3030604)  
   1. [\z 文字列の末尾にマッチ](#regularDesktopReference3030605)  
   1. [\G 前回のマッチの末尾にマッチ](#regularDesktopReference3030606)  
   1. [\b{X} Unicodeの書記素クラスタ / 単語 / 文の境界にマッチ](#regularDesktopReference3030607)  
   1. [グループ化構成体](#regularDesktopReference3030700)  
   1. [(?:pattern) 部分正規表現のグルーピング（キャプチャなし）](#regularDesktopReference3030701)  
   1. [(?=pattern) patternがこの位置の右に存在する場合にマッチ（肯定先読み）](#regularDesktopReference3030702)  
   1. [(?!pattern) patternがこの位置の右に存在しない場合にマッチ（否定先読み）](#regularDesktopReference3030703)  
   1. [(?<=pattern) patternがこの位置の左に存在する場合にマッチ（肯定戻り読み）](#regularDesktopReference3030704)  
   1. [(? 03-07-06　(?>pattern) マッチ文字列に対するバックトラックを禁止する](#regularDesktopReference3030705)  
   1. [(?(condition)yes-pattern) conditionが成立した場合は、yes-patternにマッチするかどうかを試す](#regularDesktopReference3030707)  
   1. [(?Ppattern)、(?pattern) 名前付きキャプチャ](#regularDesktopReference3030708)  
   1. [修飾子](#regularDesktopReference3030800)  
   1. [i修飾子 大文字 / 小文字の違いを無視する](#regularDesktopReference3030801)  
   1. [c修飾子 マッチに失敗しても、前回のマッチ位置をリセットしない](#regularDesktopReference3030802)  
   1. [d修飾子 UNIXラインモードにする](#regularDesktopReference3030803)  
   1. [e修飾子 置換文字列をPerlコードとして評価し、その結果を利用する](#regularDesktopReference3030804)  
   1. [g修飾子 繰り返しマッチを行う](#regularDesktopReference3030805)  
   1. [m修飾子 マルチラインモードにする](#regularDesktopReference3030806)  
   1. [o修飾子 正規表現を1回だけコンパイルする](#regularDesktopReference3030807)  
   1. [s修飾子 シングルラインモードにする](#regularDesktopReference3030808)  
   1. [u修飾子 Unicodeサポートの強化](#regularDesktopReference3030809)  
   1. [x修飾子 パターン内で空白とコメントが利用可能となる](#regularDesktopReference3030810)  
   1. [A修飾子 強制的に文字列先頭にマッチさせる](#regularDesktopReference3030811)  
   1. [D修飾子 「$」を文字列の末尾にのみマッチさせる](#regularDesktopReference3030812)  
   1. [U修飾子 「欲張り」と「無欲」の役割を反転させる(PHP)、文字クラスのマッチ対象をUnicodeベースにする(Java)](#regularDesktopReference3030813)  
   1. [X修飾子 PCREの付加機能を有効にする](#regularDesktopReference3030814)  
   1. [CANON\_EQフラグ 等価とみなされる文字を同じ文字としてマッチ](#regularDesktopReference3030815)  
   1. [(?modifier)、(?-modifier) これ以降、指定した処理モードを利用する](#regularDesktopReference3030816)  
   1. [(?modifier:pattern)、(?-modifier:pattern) 指定した処理モードを部分正規表現に適用する（クロイスタ）](#regularDesktopReference3030817)  
   1. [y修飾子 前回のマッチ位置の直後にしかマッチさせない](#regularDesktopReference3030818)  
   1. [a修飾子 ASCII文字のみのマッチングを行う](#regularDesktopReference3030819)  
   1. [n修飾子 名前付きキャプチャのみをキャプチャする](#regularDesktopReference3030820)  
   1. [変換とエスケープ](#regularDesktopReference3030900)  
   1. [\l、\u 次の文字を小文字/ 大文字として扱う](#regularDesktopReference303-090100)  
   1. [\Q ～\E 範囲内のすべての文字をエスケープする](#regularDesktopReference303-090200)  
   1. [\L ～\E、\U ～\E 範囲内のすべての文字を小文字/ 大文字として扱う](#regularDesktopReference303-090300)  
   1. [その他](#regularDesktopReference3031000)  
   1. [(?# comment) 正規表現中のコメント](#regularDesktopReference3031001)  
   1. [(?{code}) 埋め込まれたコードを実行する](#regularDesktopReference3031002)  
   1. [(??{code}) 埋め込まれたコードを実行し、その結果を正規表現として使用](#regularDesktopReference3031003)  
   1. [\[a\-z&&\[bc\]\] ブラケット表現内での集合演算](#regularDesktopReference3031004)  
   1. [vim 独自の文字クラス](#regularDesktopReference3031005)  
   1. [vim 独自の文字クラスエスケープ](#regularDesktopReference3031006)  
   1. [\& 両方の選択肢にマッチした場合のみマッチ](#regularDesktopReference3031007)  
   1. [& マッチした内容に対する後方参照](#regularDesktopReference3031008)  
   1. [\R、\N 各種の改行にマッチ / 改行以外の文字にマッチ](#regularDesktopReference3031009)  
   1. [vim 独自のメタキャラクタ](#regularDesktopReference3031010)  

1. [逆引きリファレンス 基本編](#regularDesktopReference4000001)
   1. [基本](#regularDesktopReference4040100)  
   1. [文字「a」が連続している部分にマッチさせたい](#regularDesktopReference4040101)  
   1. [「a」が5回続いた文字列にマッチさせたい](#regularDesktopReference4040102)  
   1. [「Java SE」あるいは「JavaSE」にマッチさせたい](#regularDesktopReference4040103)  
   1. [「boy」あるいは「girl」にマッチさせたい](#regularDesktopReference4040104)  
   1. [「.」そのものにマッチさせたい](#regularDesktopReference4040105)  
   1. [ある文字列から始まる行にマッチさせたい](#regularDesktopReference4040106)  
   1. [ある文字列で終わる行にマッチさせたい](#regularDesktopReference4040107)  
   1. [文字列の先頭 / 末尾にマッチさせたい](#regularDesktopReference4040108)  
   1. [英数字にマッチさせたい](#regularDesktopReference4040109)  
   1. [数字にマッチさせたい](#regularDesktopReference4040110)  
   1. [空白にマッチさせたい](#regularDesktopReference4040111)  
   1. [「book」という単語そのものにマッチさせたい](#regularDesktopReference4040112)  
   1. [任意の単語にマッチさせたい](#regularDesktopReference4040113)  
   1. [コード値で文字を指定したい](#regularDesktopReference4040114)  
   1. [制御文字にマッチさせたい](#regularDesktopReference4040115)  
   1. [大文字と小文字を区別せずにマッチさせたい](#regularDesktopReference4040116)  
   1. [「a」以外の1文字にマッチさせたい](#regularDesktopReference4040117)  
   1. [「c」と「x」を除くアルファベット小文字にマッチさせたい](#regularDesktopReference4040118)  
   1. [最初に現れる「/」までにマッチさせたい](#regularDesktopReference4040119)  
   1. [指定したパターンが繰り返し登場するかどうかを調べたい](#regularDesktopReference4040120)  
   1. [「Japan」にはマッチするが「Japanese」にはマッチしない](#regularDesktopReference4040121)  
   1. [「社長」にはマッチするが「副社長」にはマッチしない](#regularDesktopReference4040122)  
   1. [ひらがな / カタカナ / 漢字にマッチさせたい](#regularDesktopReference4040123)  

1. [逆引きリファレンス 応用編](#regularDesktopReference5000001)
   1. [応用編イントロダクション](#regularDesktopReference5050000)  
   1. [応用編での正規表現について](#regularDesktopReference5050000)  
   1. [一般](#regularDesktopReference5050100)  
   1. [空白しかない行にマッチさせたい](#regularDesktopReference505-010100)  
   1. [まったく同じ文字 / 単語が連続する部分にマッチさせたい](#regularDesktopReference505-010200)  
   1. [文字列「abc」から始まらない行にマッチさせたい](#regularDesktopReference505-010300)  
   1. [文字列「abc」が含まれない行にマッチさせたい](#regularDesktopReference505-010400)  
   1. [大文字が3文字以上連続した単語にマッチさせたい](#regularDesktopReference505-010500)  
   1. [ダブルクォートで括られた文字列にマッチさせたい](#regularDesktopReference505-010600)  
   1. [小数にマッチさせたい](#regularDesktopReference505-010700)  
   1. [指数表記の数値にマッチさせたい](#regularDesktopReference505-010800)  
   1. [3桁区切りの数値にマッチさせたい](#regularDesktopReference505-010900)  
   1. [HTML/XML](#regularDesktopReference5050200)  
   1. [URLにマッチさせたい](#regularDesktopReference5050201)  
   1. [HTML内の色指定にマッチさせたい](#regularDesktopReference5050202)  
   1. [HTMLのa要素からhref属性の値を抜き出したい](#regularDesktopReference5050203)  
   1. [HTMLの見出し要素の内容を抜き出したい](#regularDesktopReference5050204)  
   1. [HTML/XMLの開始タグにマッチさせたい](#regularDesktopReference5050205)  
   1. [type属性がhidden以外のinput要素にマッチさせたい](#regularDesktopReference5050206)  
   1. [日付 / 時刻](#regularDesktopReference5050300)  
   1. [年月日の表記にマッチさせたい](#regularDesktopReference5050301)  
   1. [「19:58:02」形式にマッチさせたい](#regularDesktopReference5050302)  
   1. [プログラミング](#regularDesktopReference5050400)  
   1. [郵便番号にマッチさせたい](#regularDesktopReference5050401)  
   1. [電話番号にマッチさせたい](#regularDesktopReference5050402)  
   1. [「キー=値」という形式にマッチさせたい](#regularDesktopReference5050403)  
   1. [Windowsのフルパス形式にマッチさせたい](#regularDesktopReference5050404)  
   1. [Windowsの特殊ファイル名にマッチさせたい](#regularDesktopReference5050405)  
   1. [IPアドレス（IPv4）にマッチさせたい](#regularDesktopReference5050406)  
   1. [ホスト名（FQDN）にマッチさせたい](#regularDesktopReference5050407)  
   1. [パーセントエンコーディングにマッチさせたい](#regularDesktopReference5050408)  
   1. [エンコードされたメールヘッダにマッチさせたい](#regularDesktopReference5050409)  
   1. [クエリ文字列を分解したい](#regularDesktopReference5050410)  
   1. [メールアドレスにマッチさせたい](#regularDesktopReference5050411)  
   1. [プログラム解析](#regularDesktopReference5050500)  
   1. [Cプログラムからインクルードされたファイルを抜き出したい](#regularDesktopReference5050501)  
   1. [スクリプトからヒア・ドキュメントを抜き出したい](#regularDesktopReference5050502)  

1. [逆引きリファレンス 置換編](#regularDesktopReference6000001)
   1. [置換編イントロダクション](#regularDesktopReference6060000)  
   1. [置換編での正規表現について](#regularDesktopReference6060000)  
   1. [文書作成](#regularDesktopReference6060100)  
   1. [行と行の間に空行を追加したい](#regularDesktopReference6060101)  
   1. [文の区切りで改行を入れたい](#regularDesktopReference6060102)  
   1. [行の先頭及び末尾の空白を削除したい](#regularDesktopReference6060103)  
   1. [カンマの後ろのスペースを1つに統一したい](#regularDesktopReference6060104)  
   1. [ピリオドの後ろのスペースを2つに統一したい](#regularDesktopReference6060105)  
   1. [段落を保持したまま複数行を1行にしたい](#regularDesktopReference6060106)  
   1. [英数字 / 英単語と日本語の文字の間にスペースを挾みたい](#regularDesktopReference6060107)  
   1. [単語の先頭の文字を大文字に変換したい](#regularDesktopReference6060108)  
   1. [各単語の先頭1文字から頭字語を作成したい](#regularDesktopReference6060109)  
   1. [HTML/XML](#regularDesktopReference6060200)  
   1. [「sample.html#p1」から、#より前 / 後の文字列を削除したい](#regularDesktopReference6060201)  
   1. [「&」をすべて「&」に置換したい](#regularDesktopReference6060202)  
   1. [XMLの「<要素名/>」を「<要素名>」に変換したい](#regularDesktopReference6060203)  
   1. [タグの外部にある「green」をすべて「yellow」に変換したい](#regularDesktopReference6060204)  
   1. [HTML/XMLのコメントを削除したい](#regularDesktopReference6060205)  
   1. [プログラミング](#regularDesktopReference6060300)  
   1. [クエリ文字列から値が入っていないフォームデータを排除したい](#regularDesktopReference6060301)  
   1. [「product\_name」を「productName」に変換したい](#regularDesktopReference6060302)  
   1. [「PRODUCT\_NAME」を「productName」に変換したい](#regularDesktopReference6060303)  
   1. [メールの引用符を取り除きたい](#regularDesktopReference6060304)  
   1. [ファイル名から拡張子を除去したい](#regularDesktopReference6060305)  
   1. [パス名からファイル名部分以外を除去したい](#regularDesktopReference6060306)  
   1. [プログラム解析](#regularDesktopReference6060400)  
   1. [Javaプログラムからコメントを削除したい](#regularDesktopReference6060401)  
   1. [Perlプログラムからコメントを削除したい](#regularDesktopReference6060402)  
   1. [Cプログラムからコメントを削除したい](#regularDesktopReference6060403)  

1. [APPENDIX](#regularDesktopReference9000001)
   1. [ASCII](#regularDesktopReference9AP0100)  
   1. [ASCIIの制御文字一覧](#regularDesktopReference9APAP0101)  
   1. [Unicode](#regularDesktopReference9APAPAP0200)  
   1. [Unicode 一般カテゴリ一覧](#regularDesktopReference9APAPAPAP0201)  

1. [INDEX](#regularDesktopReferenceA000001)
1. [個人メモ](#memo1999)  


<a id="oreilly9784873113593contents"></a>
## [詳説 正規表現 第3版-目次](#oreilly9784873113593)
1. [はじめに](#regularOreillyDetailedExplanation00000001)
1. 章　[正規表現入門](#regularOreillyDetailedExplanation10000001)  
   1. [現実の問題を解決するために](#regularOreillyDetailedExplanation1011)  
   1. [言語としての正規表現](#regularOreillyDetailedExplanation1012)  
      1. [ファイル名との類似点](#regularOreillyDetailedExplanation10121)  
      1. [言語との類似点](#regularOreillyDetailedExplanation10122)  
   1. [正規表現という思考の枠組み](#regularOreillyDetailedExplanation1013)  
      1. [ある程度正規表現のことを知っているなら](#regularOreillyDetailedExplanation10131)  
      1. [ファイルからのテキストの検索：egrep](#regularOreillyDetailedExplanation10132)  
   1. [egrepのメタ文字](#regularOreillyDetailedExplanation1014)  
      1. [行頭と行末](#regularOreillyDetailedExplanation10141)  
      1. [文字クラス](#regularOreillyDetailedExplanation10142)  
      1. [任意の文字にマッチするドット](#regularOreillyDetailedExplanation10143)  
      1. [選択](#regularOreillyDetailedExplanation10144)  
      1. [大文字と小文字の違いを無視する](#regularOreillyDetailedExplanation10145)  
      1. [単語の境界](#regularOreillyDetailedExplanation10146)  
      1. [これまでのまとめ](#regularOreillyDetailedExplanation10147)  
      1. [量指定子：オプション](#regularOreillyDetailedExplanation10148)  
      1. [その他の量指定子：繰り返し](#regularOreillyDetailedExplanation10149)  
      1. [括弧と後方参照](#regularOreillyDetailedExplanation101410)  
      1. [大脱走――偉大なるエスケープ](#regularOreillyDetailedExplanation101411)  
   1. [基礎を発展させる](#regularOreillyDetailedExplanation1015)  
      1. [言語の多様性](#regularOreillyDetailedExplanation10151)  
      1. [正規表現の目的](#regularOreillyDetailedExplanation10152)  
      1. [実例をもっと](#regularOreillyDetailedExplanation10153)  
      1. [正規表現の用語](#regularOreillyDetailedExplanation10154)  
      1. [現状の打破](#regularOreillyDetailedExplanation10155)  
      1. [まとめ](#regularOreillyDetailedExplanation10156)  
   1. [章の終わりに一言](#regularOreillyDetailedExplanation1016)  

1. 章　[初心者向けのサンプル](#regularOreillyDetailedExplanation20000001)
   1. [サンプルについて](#regularOreillyDetailedExplanation2021)  
      1. [Perlの簡単な解説](#regularOreillyDetailedExplanation20211)  
   1. [正規表現をテキストにマッチさせる](#regularOreillyDetailedExplanation2022)  
      1. [もっと本格的に](#regularOreillyDetailedExplanation20221)  
      1. [マッチが成功したときの副作用](#regularOreillyDetailedExplanation20222)  
      1. [入り組んだ正規表現](#regularOreillyDetailedExplanation20223)  
      1. [中締め](#regularOreillyDetailedExplanation20224)  
   1. [正規表現によるテキストの書き換え](#regularOreillyDetailedExplanation2023)  
      1. [サンプル：ダイレクトメール](#regularOreillyDetailedExplanation20231)  
      1. [サンプル：株価表示の整形](#regularOreillyDetailedExplanation20232)  
      1. [自動編集](#regularOreillyDetailedExplanation20233)  
      1. [ささやかなメールユーティリティ](#regularOreillyDetailedExplanation20234)  
      1. [先後読みによって数値にカンマを付け加える](#regularOreillyDetailedExplanation20235)  
      1. [テキストからHTMLへの変換](#regularOreillyDetailedExplanation20236)  
      1. [語の重複問題再説](#regularOreillyDetailedExplanation20237)  

1. 章　[正規表現の機能と方言](#regularOreillyDetailedExplanation30000001)
   1. [正規表現のスケッチ](#regularOreillyDetailedExplanation3031)  
      1. [正規表現の起源](#regularOreillyDetailedExplanation30311)  
      1. [一見してわかる違い](#regularOreillyDetailedExplanation30312)  
   1. [正規表現処理のインタフェース](#regularOreillyDetailedExplanation3032)  
      1. [統合型インタフェース](#regularOreillyDetailedExplanation30321)  
      1. [手続き型、オブジェクト指向型インタフェース](#regularOreillyDetailedExplanation30322)  
      1. [置換のサンプル](#regularOreillyDetailedExplanation30323)  
      1. [その他の言語による置換](#regularOreillyDetailedExplanation30324)  
      1. [インタフェースのまとめ](#regularOreillyDetailedExplanation30325)  
   1. [文字列、コード体系、モード](#regularOreillyDetailedExplanation3033)  
      1. [正規表現を表す文字列](#regularOreillyDetailedExplanation30331)  
      1. [コード体系の問題](#regularOreillyDetailedExplanation30332)  
      1. [Unicode](#regularOreillyDetailedExplanation30333)  
      1. [正規表現モードとマッチモード](#regularOreillyDetailedExplanation30334)  
   1. [よく使われるメタ文字とその機能](#regularOreillyDetailedExplanation3034)  
      1. [文字の表現](#regularOreillyDetailedExplanation30341)  
      1. [文字クラスと文字クラス的な構文](#regularOreillyDetailedExplanation30342)  
      1. [アンカーなどの“ゼロ幅マッチ”](#regularOreillyDetailedExplanation30343)  
      1. [コメントとモード修飾子](#regularOreillyDetailedExplanation30344)  
      1. [グループ化、キャプチャ、条件分岐、制御構造](#regularOreillyDetailedExplanation30345)  
   1. [高度な内容を扱う章に進むための指針](#regularOreillyDetailedExplanation3035)  

1. 章　[正規表現処理のメカニズム](#regularOreillyDetailedExplanation40000001)
   1. [エンジン始動](#regularOreillyDetailedExplanation4041)  
      1. [2種類のエンジン](#regularOreillyDetailedExplanation40411)  
      1. [新基準](#regularOreillyDetailedExplanation40412)  
      1. [正規表現エンジンのタイプ](#regularOreillyDetailedExplanation40413)  
      1. [合衆国冗長省からの要請](#regularOreillyDetailedExplanation40414)  
      1. [エンジンのタイプのテスト](#regularOreillyDetailedExplanation40415)  
   1. [マッチの基本原則](#regularOreillyDetailedExplanation4042)  
      1. [サンプルについて](#regularOreillyDetailedExplanation40421)  
      1. [原則1：最初にマッチしたものが優先される](#regularOreillyDetailedExplanation40422)  
      1. [エンジンの部品](#regularOreillyDetailedExplanation40423)  
      1. [原則2：標準の量指定子は欲張りである](#regularOreillyDetailedExplanation40424)  
   1. [正規表現主導かテキスト主導か](#regularOreillyDetailedExplanation4043)  
      1. [正規表現主導型のNFAエンジン](#regularOreillyDetailedExplanation40431)  
      1. [テキスト主導型のDFAエンジン](#regularOreillyDetailedExplanation40432)  
      1. [NFAとDFAの比較：最初の考察](#regularOreillyDetailedExplanation40433)  
   1. [バックトラック](#regularOreillyDetailedExplanation4044)  
      1. [パン切れのたとえ](#regularOreillyDetailedExplanation40441)  
      1. [バックトラックに関する2つの重要なポイント](#regularOreillyDetailedExplanation40442)  
      1. [保存ステート](#regularOreillyDetailedExplanation40443)  
      1. [バックトラックと欲張り度](#regularOreillyDetailedExplanation40444)  
   1. [さらに、欲張りなこととバックトラックについて](#regularOreillyDetailedExplanation4045)  
      1. [欲張りな動作の問題点](#regularOreillyDetailedExplanation40451)  
      1. [複数の文字による“クォート”](#regularOreillyDetailedExplanation40452)  
      1. [控え目な量指定子の使い方](#regularOreillyDetailedExplanation40453)  
      1. [欲張りでも控え目でも常にマッチ優先](#regularOreillyDetailedExplanation40454)  
      1. [欲張り、控え目、バックトラックの本質](#regularOreillyDetailedExplanation40455)  
      1. [絶対最大量指定子とアトミックグループ](#regularOreillyDetailedExplanation40456)  
      1. [絶対最大量指定子：?+、*+、++、{m,n}+](#regularOreillyDetailedExplanation40457)  
      1. [先後読みのバックトラック](#regularOreillyDetailedExplanation40458)  
      1. [選択は欲張りか](#regularOreillyDetailedExplanation40459)  
      1. [早い者勝ち選択の活用方法](#regularOreillyDetailedExplanation404510)  
   1. [NFA、DFA、POSIX](#regularOreillyDetailedExplanation4046)  
      1. [最左最長](#regularOreillyDetailedExplanation40461)  
      1. [POSIXと最左最長原則](#regularOreillyDetailedExplanation40462)  
      1. [スピードと効率](#regularOreillyDetailedExplanation40463)  
      1. [NFAとDFAの比較：まとめ](#regularOreillyDetailedExplanation40464)  
   1. [まとめ](#regularOreillyDetailedExplanation4047)  

1. 章　[正規表現の実践的なテクニック](#regularOreillyDetailedExplanation50000001)
   1. [正規表現の平衡感覚](#regularOreillyDetailedExplanation5051)  
   1. [短めのサンプル](#regularOreillyDetailedExplanation5052)  
      1. [継続行の継続](#regularOreillyDetailedExplanation50521)  
      1. [IPアドレスへのマッチ](#regularOreillyDetailedExplanation50522)  
      1. [ファイル名の操作](#regularOreillyDetailedExplanation50523)  
      1. [括弧類の対へのマッチ](#regularOreillyDetailedExplanation50524)  
      1. [望ましくないマッチを減らすには](#regularOreillyDetailedExplanation50525)  
      1. [区切り子の入ったテキストへのマッチ](#regularOreillyDetailedExplanation50526)  
      1. [データの知識を活用して前提条件を意識する](#regularOreillyDetailedExplanation50527)  
      1. [先頭や末尾の空白の除去](#regularOreillyDetailedExplanation50528)  
   1. [HTML関連のサンプル](#regularOreillyDetailedExplanation5053)  
      1. [HTMLタグへのマッチ](#regularOreillyDetailedExplanation50531)  
      1. [HTMLリンクへのマッチ](#regularOreillyDetailedExplanation50532)  
      1. [HTTP URLの解析](#regularOreillyDetailedExplanation50533)  
      1. [ホスト名のチェック](#regularOreillyDetailedExplanation50534)  
      1. [URLを抽出する実用的なコード](#regularOreillyDetailedExplanation50535)  
   1. [高度なサンプル](#regularOreillyDetailedExplanation5054)  
      1. [データとの同期の確保](#regularOreillyDetailedExplanation50541)  
      1. [CSVファイルの走査](#regularOreillyDetailedExplanation50542)  

1. 章　[効率のよい正規表現の作り方](#regularOreillyDetailedExplanation60000001)
   1. [酔いも醒めるようなサンプル](#regularOreillyDetailedExplanation6061)  
      1. [簡単な変更――効き足を先に](#regularOreillyDetailedExplanation60611)  
      1. [効率と正しさ](#regularOreillyDetailedExplanation60612)  
      1. [さらに改良――欲張りな動作の局所化](#regularOreillyDetailedExplanation60613)  
      1. [現実性のチェック](#regularOreillyDetailedExplanation60614)  
   1. [バックトラックの全体像](#regularOreillyDetailedExplanation6062)  
      1. [POSIX NFAの余分な仕事](#regularOreillyDetailedExplanation60621)  
      1. [マッチ不成功のときに必要な仕事](#regularOreillyDetailedExplanation60622)  
      1. [より厳密に](#regularOreillyDetailedExplanation60623)  
      1. [選択は高くつく場合がある](#regularOreillyDetailedExplanation60624)  
   1. [ベンチマークテスト](#regularOreillyDetailedExplanation6063)  
      1. [何を計測しているのかを把握する](#regularOreillyDetailedExplanation60631)  
      1. [PHPによるベンチマークテスト](#regularOreillyDetailedExplanation60632)  
      1. [Javaによるベンチマークテスト](#regularOreillyDetailedExplanation60633)  
      1. [VB.NETによるベンチマークテスト](#regularOreillyDetailedExplanation60634)  
      1. [Rubyによるベンチマークテスト](#regularOreillyDetailedExplanation60635)  
      1. [Pythonによるベンチマークテスト](#regularOreillyDetailedExplanation60636)  
      1. [Tclによるベンチマークテスト](#regularOreillyDetailedExplanation60637)  
   1. [よく見られる最適化](#regularOreillyDetailedExplanation6064)  
      1. [タダでは手に入らない](#regularOreillyDetailedExplanation60641)  
      1. [実装による違い](#regularOreillyDetailedExplanation60642)  
      1. [正規表現適用のメカニズム](#regularOreillyDetailedExplanation60643)  
      1. [適用前の最適化](#regularOreillyDetailedExplanation60644)  
      1. [トランスミッションの最適化](#regularOreillyDetailedExplanation60645)  
      1. [正規表現自体の最適化](#regularOreillyDetailedExplanation60646)  
   1. [より高速な正規表現を書くためのテクニック](#regularOreillyDetailedExplanation6065)  
      1. [常識的なテクニック](#regularOreillyDetailedExplanation60651)  
      1. [リテラルテキストを目立たせる](#regularOreillyDetailedExplanation60652)  
      1. [アンカーを目立たせる](#regularOreillyDetailedExplanation60653)  
      1. [最小量指定子と最大量指定子の使い分け](#regularOreillyDetailedExplanation60654)  
      1. [複数の正規表現への分割](#regularOreillyDetailedExplanation60655)  
      1. [先頭文字の識別の模倣](#regularOreillyDetailedExplanation60656)  
      1. [アトミックグループと絶対最大量指定子を使う](#regularOreillyDetailedExplanation60657)  
      1. [エンジンをマッチに導く](#regularOreillyDetailedExplanation60658)  
   1. [ループ展開](#regularOreillyDetailedExplanation6066)  
      1. [方法1：過去の経験に基づいて正規表現を組み立てる](#regularOreillyDetailedExplanation60661)  
      1. [本物の“ループ展開”パターン](#regularOreillyDetailedExplanation60662)  
      1. [方法2：トップダウンの視点](#regularOreillyDetailedExplanation60663)  
      1. [方法3：インターネットのホスト名](#regularOreillyDetailedExplanation60664)  
      1. [所見](#regularOreillyDetailedExplanation60665)  
      1. [アトミックグループや絶対最大量指定子を使った方法](#regularOreillyDetailedExplanation60666)  
      1. [ループ展開の簡単なサンプル](#regularOreillyDetailedExplanation60667)  
      1. [Cコメントのループ展開](#regularOreillyDetailedExplanation60668)  
   1. [スムーズに流れる正規表現](#regularOreillyDetailedExplanation6067)  
      1. [マッチを導く救いの手](#regularOreillyDetailedExplanation60671)  
      1. [正規表現を適切な方向に導いて高速化する](#regularOreillyDetailedExplanation60672)  
      1. [最後に](#regularOreillyDetailedExplanation60673)  
   1. [まとめ：考えよ！](#regularOreillyDetailedExplanation6068)  

1. 章　[Perl](#regularOreillyDetailedExplanation70000001)
   1. [言語の構成要素としての正規表現](#regularOreillyDetailedExplanation7071)  
      1. [Perlの最大の長所](#regularOreillyDetailedExplanation70711)  
      1. [Perlの最大の弱点](#regularOreillyDetailedExplanation70712)  
   1. [正規表現のPerl方言](#regularOreillyDetailedExplanation7072)  
      1. [正規表現被演算子と正規表現リテラル](#regularOreillyDetailedExplanation70721)  
      1. [正規表現リテラルの走査の仕組み](#regularOreillyDetailedExplanation70722)  
      1. [正規表現修飾子](#regularOreillyDetailedExplanation70723)  
   1. [正規表現関連のPerlイズム](#regularOreillyDetailedExplanation7073)  
      1. [式のコンテキスト](#regularOreillyDetailedExplanation70731)  
      1. [動的スコープと正規表現マッチに対するその影響](#regularOreillyDetailedExplanation70732)  
      1. [マッチによって書き換えられる特殊変数](#regularOreillyDetailedExplanation70733)  
   1. [qr/…/演算子と正規表現オブジェクト](#regularOreillyDetailedExplanation7074)  
      1. [正規表現オブジェクトの作り方と使い方](#regularOreillyDetailedExplanation70741)  
      1. [正規表現オブジェクトの表示](#regularOreillyDetailedExplanation70742)  
      1. [効率向上のために正規表現オブジェクトを使う方法](#regularOreillyDetailedExplanation70743)  
   1. [マッチ演算子](#regularOreillyDetailedExplanation7075)  
      1. [マッチ演算子の正規表現被演算子](#regularOreillyDetailedExplanation70751)  
      1. [マッチターゲット被演算子の指定方法](#regularOreillyDetailedExplanation70752)  
      1. [マッチ演算子のさまざまな使い方](#regularOreillyDetailedExplanation70753)  
      1. [反復的なマッチ――/gありのスカラーコンテキスト](#regularOreillyDetailedExplanation70754)  
      1. [マッチ演算子と環境との関係](#regularOreillyDetailedExplanation70755)  
   1. [置換演算子](#regularOreillyDetailedExplanation7076)  
      1. [置換被演算子](#regularOreillyDetailedExplanation70761)  
      1. [/e修飾子](#regularOreillyDetailedExplanation70762)  
      1. [コンテキストと戻り値](#regularOreillyDetailedExplanation70763)  
   1. [split演算子](#regularOreillyDetailedExplanation7077)  
      1. [splitの基本](#regularOreillyDetailedExplanation70771)  
      1. [空要素](#regularOreillyDetailedExplanation70772)  
      1. [splitの特殊なマッチ被演算子](#regularOreillyDetailedExplanation70773)  
      1. [キャプチャ付き括弧を含むsplitのマッチ被演算子](#regularOreillyDetailedExplanation70774)  
   1. [Perlの拡張機能](#regularOreillyDetailedExplanation7078)  
      1. [動的正規表現を使って入れ子の対にマッチさせる](#regularOreillyDetailedExplanation70781)  
      1. [組み込みコードの使い方](#regularOreillyDetailedExplanation70782)  
      1. [組み込みコードでのlocalの使い方](#regularOreillyDetailedExplanation70783)  
      1. [組み込みコードとmy変数についての注意](#regularOreillyDetailedExplanation70784)  
      1. [組み込みコードを使った入れ子構造のマッチ](#regularOreillyDetailedExplanation70785)  
      1. [正規表現リテラルのオーバーロード](#regularOreillyDetailedExplanation70786)  
      1. [正規表現リテラルのオーバーロードに関する問題点](#regularOreillyDetailedExplanation70787)  
      1. [名前付きキャプチャの模倣](#regularOreillyDetailedExplanation70788)  
   1. [Perlの効率性の問題](#regularOreillyDetailedExplanation7079)  
      1. [やり方は1つではない](#regularOreillyDetailedExplanation70791)  
      1. [正規表現のコンパイルや/o修飾子、qr/…/と処理効率](#regularOreillyDetailedExplanation70792)  
      1. [“プレマッチ”コピーの動作](#regularOreillyDetailedExplanation70793)  
      1. [study関数](#regularOreillyDetailedExplanation70794)  
      1. [ベンチマークテスト](#regularOreillyDetailedExplanation70795)  
      1. [正規表現のデバッグ情報](#regularOreillyDetailedExplanation70796)  
   1. [最後に言っておきたいこと](#regularOreillyDetailedExplanation70710)  

1. 章　[Java](#regularOreillyDetailedExplanation80000001)
   1. [正規表現のJava方言](#regularOreillyDetailedExplanation8081)  
      1. [Javaにおける\p{…}と\P{…}のサポート](#regularOreillyDetailedExplanation80811)  
      1. [Unicodeの行終端子](#regularOreillyDetailedExplanation80812)  
   1. [java.util.regexの使い方](#regularOreillyDetailedExplanation8082)  
   1. [Pattern.compile()ファクトリ](#regularOreillyDetailedExplanation8083)  
      1. [パターンのmatcherメソッド](#regularOreillyDetailedExplanation80831)  
   1. [Matcherオブジェクト](#regularOreillyDetailedExplanation8084)  
      1. [正規表現の適用](#regularOreillyDetailedExplanation80841)  
      1. [マッチの結果の問い合わせ](#regularOreillyDetailedExplanation80842)  
      1. [単純な置換](#regularOreillyDetailedExplanation80843)  
      1. [高度な置換](#regularOreillyDetailedExplanation80844)  
      1. [その場での置換](#regularOreillyDetailedExplanation80845)  
      1. [マッチャのリージョン](#regularOreillyDetailedExplanation80846)  
      1. [メソッドのチェーン化](#regularOreillyDetailedExplanation80847)  
      1. [字句解析器を作るためのメソッド](#regularOreillyDetailedExplanation80848)  
      1. [その他のマッチャメソッド](#regularOreillyDetailedExplanation80849)  
   1. [パターンのその他のメソッド](#regularOreillyDetailedExplanation8085)  
      1. [パターンのsplitメソッド（引数1個バージョン）](#regularOreillyDetailedExplanation80851)  
      1. [パターンのsplitメソッド（引数2個バージョン）](#regularOreillyDetailedExplanation80852)  
   1. [サンプルをもっと](#regularOreillyDetailedExplanation8086)  
      1. [IMGタグにWIDTH属性とHEIGHT属性を追加する](#regularOreillyDetailedExplanation80861)  
      1. [1つのマッチャで複数のパターンを使ってHTMLをチェックする](#regularOreillyDetailedExplanation80862)  
      1. [CSVテキストを走査する](#regularOreillyDetailedExplanation80863)  
   1. [Javaのバージョンによる違い](#regularOreillyDetailedExplanation8087)  
      1. [1.4.2と1.5.0との違い](#regularOreillyDetailedExplanation80871)  
      1. [1.5.0と1.6との違い](#regularOreillyDetailedExplanation80872)  

1. 章　[.NET](#regularOreillyDetailedExplanation90000001)
   1. [正規表現の.NET方言](#regularOreillyDetailedExplanation9091)  
      1. [.NET方言についての補足](#regularOreillyDetailedExplanation90911)  
   1. [.NET正規表現の使い方](#regularOreillyDetailedExplanation9092)  
      1. [手っ取り早く正規表現を使うには](#regularOreillyDetailedExplanation90921)  
      1. [パッケージの概要](#regularOreillyDetailedExplanation90922)  
      1. [コアオブジェクトの概要](#regularOreillyDetailedExplanation90923)  
   1. [コアオブジェクトの詳細](#regularOreillyDetailedExplanation9093)  
      1. [Regexオブジェクトの作り方](#regularOreillyDetailedExplanation90931)  
      1. [Regexオブジェクトの使い方](#regularOreillyDetailedExplanation90932)  
      1. [Matchオブジェクトの使い方](#regularOreillyDetailedExplanation90933)  
      1. [Groupオブジェクトの使い方](#regularOreillyDetailedExplanation90934)  
   1. [ユーティリティ関数として使える静的関数](#regularOreillyDetailedExplanation9094)  
      1. [正規表現のキャッシング](#regularOreillyDetailedExplanation90941)  
   1. [サポート関数](#regularOreillyDetailedExplanation9095)  
   1. [.NET正規表現の高度な機能](#regularOreillyDetailedExplanation9096)  
      1. [正規表現アセンブリ](#regularOreillyDetailedExplanation90961)  
      1. [入れ子構造に対するマッチ](#regularOreillyDetailedExplanation90962)  
      1. [Captureオブジェクト](#regularOreillyDetailedExplanation90963)  

1. 章　[PHP](#regularOreillyDetailedExplanation100000001)
   1. [正規表現のPHP方言](#regularOreillyDetailedExplanation10101)  
   1. [preg関数のインタフェース](#regularOreillyDetailedExplanation10102)  
      1. [“パターン”引数](#regularOreillyDetailedExplanation101021)  
   1. [preg関数](#regularOreillyDetailedExplanation10103)  
      1. [preg_match](#regularOreillyDetailedExplanation101031)  
      1. [preg_match_all](#regularOreillyDetailedExplanation101032)  
      1. [preg_replace](#regularOreillyDetailedExplanation101033)  
      1. [preg_replace_callback](#regularOreillyDetailedExplanation101034)  
      1. [preg_split](#regularOreillyDetailedExplanation101035)  
      1. [preg_grep](#regularOreillyDetailedExplanation101036)  
      1. [preg_quote](#regularOreillyDetailedExplanation101037)  
   1. [“欠けている”preg関数](#regularOreillyDetailedExplanation10104)  
      1. [正規表現文字列からpregパターン文字列への変換](#regularOreillyDetailedExplanation101041)  
      1. [未知のパターン引数の構文チェック](#regularOreillyDetailedExplanation101042)  
      1. [未知の正規表現の構文チェック](#regularOreillyDetailedExplanation101043)  
   1. [再帰式](#regularOreillyDetailedExplanation10105)  
      1. [括弧が入れ子構造になっているテキストとのマッチ](#regularOreillyDetailedExplanation101051)  
      1. [再帰の中へのバックトラック](#regularOreillyDetailedExplanation101052)  
      1. [入れ子構造になっている1組の括弧へのマッチ](#regularOreillyDetailedExplanation101053)  
   1. [PHPの処理効率の問題](#regularOreillyDetailedExplanation10106)  
      1. [Sパターン修飾子：“study”](#regularOreillyDetailedExplanation101061)  
   1. [サンプルコードをさらに](#regularOreillyDetailedExplanation10107)  
      1. [PHPによるCSV走査](#regularOreillyDetailedExplanation101071)  
      1. [タグ付きデータが適切な入れ子構造になっているかのチェック](#regularOreillyDetailedExplanation101072)  

1. [索引](#regularOreillyDetailedExplanation99999999)

1. [個人メモ](#memo2999)  

---
## 参考書籍(3冊目)。
書籍：  
ISBN：  
ASIN：  
著者：  
著者：  
発行：YYYY/MM/DD 発売日  
出版社：  
関連先URL：<URL>  
形式：単行本  

### 目次
1. [個人メモ](#memo3999)  


---
<!-- リンク先(目次部分のリンクの飛び先) -->
## ーーー　上位、後ろの章になり、下側に若い章が来る。  

<a id="memo99999"></a>
### 個人メモ(総合的な優先度の高いメモ)
基本的に、Perl互換の正規表現が利用できることを謳うテキストエディタなどがあり、Perlの検索エンジンが優れていると判断できる(本当に？)。  
ということで、できる限りPerlを基準にした正規表現を勉強していこうと思う。  
ちなみに、vimは、[NFAエンジン](https://vim-jp.org/vimdoc-ja/pattern.html#NFA)を使っているようだ(で、それは何？)。  
そして、vimで検索をするときは`very magic`を有効にする(`\v`)。  
しかし、自動でそれが有効になるように設定しているのだが、置換などの時は自動に有効化させていないため、検索結果が異なり、戸惑う。
結構困る。  











---
<a id="oreilly9784873113593"></a>
## 書籍：**詳説 正規表現 第3版**

<a id="regularOreillyDetailedExplanation100000001"></a>
### PHP

<a id="regularOreillyDetailedExplanation10101"></a>
#### 正規表現のPHP方言


<a id="regularOreillyDetailedExplanation10102"></a>
#### preg関数のインタフェース

<a id="regularOreillyDetailedExplanation101021"></a>
##### “パターン”引数



<a id="regularOreillyDetailedExplanation10103"></a>
#### preg関数

<a id="regularOreillyDetailedExplanation101031"></a>
##### preg\_match


<a id="regularOreillyDetailedExplanation101032"></a>
##### preg\_match\_all


<a id="regularOreillyDetailedExplanation101033"></a>
##### preg\_replace


<a id="regularOreillyDetailedExplanation101034"></a>
##### preg\_replace\_callback


<a id="regularOreillyDetailedExplanation101035"></a>
##### preg\_split


<a id="regularOreillyDetailedExplanation101036"></a>
##### preg\_grep


<a id="regularOreillyDetailedExplanation101037"></a>
##### preg\_quote



<a id="regularOreillyDetailedExplanation10104"></a>
#### “欠けている”preg関数

<a id="regularOreillyDetailedExplanation101041"></a>
##### 正規表現文字列からpregパターン文字列への変換


<a id="regularOreillyDetailedExplanation101042"></a>
##### 未知のパターン引数の構文チェック


<a id="regularOreillyDetailedExplanation101043"></a>
##### 未知の正規表現の構文チェック



<a id="regularOreillyDetailedExplanation10105"></a>
#### 再帰式

<a id="regularOreillyDetailedExplanation101051"></a>
##### 括弧が入れ子構造になっているテキストとのマッチ


<a id="regularOreillyDetailedExplanation101052"></a>
##### 再帰の中へのバックトラック


<a id="regularOreillyDetailedExplanation101053"></a>
##### 入れ子構造になっている1組の括弧へのマッチ



<a id="regularOreillyDetailedExplanation10106"></a>
#### PHPの処理効率の問題

<a id="regularOreillyDetailedExplanation101061"></a>
##### Sパターン修飾子：“study”



<a id="regularOreillyDetailedExplanation10107"></a>
#### サンプルコードをさらに

<a id="regularOreillyDetailedExplanation101071"></a>
##### PHPによるCSV走査


<a id="regularOreillyDetailedExplanation101072"></a>
##### タグ付きデータが適切な入れ子構造になっているかのチェック




<a id="regularOreillyDetailedExplanation90000001"></a>
### .NET

<a id="regularOreillyDetailedExplanation9091"></a>
#### 正規表現の.NET方言

<a id="regularOreillyDetailedExplanation90911"></a>
##### .NET方言についての補足



<a id="regularOreillyDetailedExplanation9092"></a>
#### .NET正規表現の使い方

<a id="regularOreillyDetailedExplanation90921"></a>
##### 手っ取り早く正規表現を使うには


<a id="regularOreillyDetailedExplanation90922"></a>
##### パッケージの概要


<a id="regularOreillyDetailedExplanation90923"></a>
##### コアオブジェクトの概要



<a id="regularOreillyDetailedExplanation9093"></a>
#### コアオブジェクトの詳細

<a id="regularOreillyDetailedExplanation90931"></a>
##### Regexオブジェクトの作り方


<a id="regularOreillyDetailedExplanation90932"></a>
##### Regexオブジェクトの使い方


<a id="regularOreillyDetailedExplanation90933"></a>
##### Matchオブジェクトの使い方


<a id="regularOreillyDetailedExplanation90934"></a>
##### Groupオブジェクトの使い方



<a id="regularOreillyDetailedExplanation9094"></a>
#### ユーティリティ関数として使える静的関数

<a id="regularOreillyDetailedExplanation90941"></a>
##### 正規表現のキャッシング



<a id="regularOreillyDetailedExplanation9095"></a>
#### サポート関数


<a id="regularOreillyDetailedExplanation9096"></a>
#### .NET正規表現の高度な機能

<a id="regularOreillyDetailedExplanation90961"></a>
##### 正規表現アセンブリ


<a id="regularOreillyDetailedExplanation90962"></a>
##### 入れ子構造に対するマッチ


<a id="regularOreillyDetailedExplanation90963"></a>
##### Captureオブジェクト




<a id="regularOreillyDetailedExplanation80000001"></a>
### Java

<a id="regularOreillyDetailedExplanation8081"></a>
#### 正規表現のJava方言

<a id="regularOreillyDetailedExplanation80811"></a>
##### Javaにおける\p{…}と\P{…}のサポート


<a id="regularOreillyDetailedExplanation80812"></a>
##### Unicodeの行終端子



<a id="regularOreillyDetailedExplanation8082"></a>
#### java.util.regexの使い方


<a id="regularOreillyDetailedExplanation8083"></a>
#### Pattern.compile()ファクトリ

<a id="regularOreillyDetailedExplanation80831"></a>
##### パターンのmatcherメソッド



<a id="regularOreillyDetailedExplanation8084"></a>
#### Matcherオブジェクト

<a id="regularOreillyDetailedExplanation80841"></a>
##### 正規表現の適用


<a id="regularOreillyDetailedExplanation80842"></a>
##### マッチの結果の問い合わせ


<a id="regularOreillyDetailedExplanation80843"></a>
##### 単純な置換


<a id="regularOreillyDetailedExplanation80844"></a>
##### 高度な置換


<a id="regularOreillyDetailedExplanation80845"></a>
##### その場での置換


<a id="regularOreillyDetailedExplanation80846"></a>
##### マッチャのリージョン


<a id="regularOreillyDetailedExplanation80847"></a>
##### メソッドのチェーン化


<a id="regularOreillyDetailedExplanation80848"></a>
##### 字句解析器を作るためのメソッド


<a id="regularOreillyDetailedExplanation80849"></a>
##### その他のマッチャメソッド



<a id="regularOreillyDetailedExplanation8085"></a>
#### パターンのその他のメソッド

<a id="regularOreillyDetailedExplanation80851"></a>
##### パターンのsplitメソッド（引数1個バージョン）


<a id="regularOreillyDetailedExplanation80852"></a>
##### パターンのsplitメソッド（引数2個バージョン）



<a id="regularOreillyDetailedExplanation8086"></a>
#### サンプルをもっと

<a id="regularOreillyDetailedExplanation80861"></a>
##### IMGタグにWIDTH属性とHEIGHT属性を追加する


<a id="regularOreillyDetailedExplanation80862"></a>
##### 1つのマッチャで複数のパターンを使ってHTMLをチェックする


<a id="regularOreillyDetailedExplanation80863"></a>
##### CSVテキストを走査する



<a id="regularOreillyDetailedExplanation8087"></a>
#### Javaのバージョンによる違い

<a id="regularOreillyDetailedExplanation80871"></a>
##### 1.4.2と1.5.0との違い


<a id="regularOreillyDetailedExplanation80872"></a>
##### 1.5.0と1.6との違い




<a id="regularOreillyDetailedExplanation70000001"></a>
### Perl

<a id="regularOreillyDetailedExplanation7071"></a>
#### 言語の構成要素としての正規表現

<a id="regularOreillyDetailedExplanation70711"></a>
##### Perlの最大の長所


<a id="regularOreillyDetailedExplanation70712"></a>
##### Perlの最大の弱点



<a id="regularOreillyDetailedExplanation7072"></a>
#### 正規表現のPerl方言

<a id="regularOreillyDetailedExplanation70721"></a>
##### 正規表現被演算子と正規表現リテラル


<a id="regularOreillyDetailedExplanation70722"></a>
##### 正規表現リテラルの走査の仕組み


<a id="regularOreillyDetailedExplanation70723"></a>
##### 正規表現修飾子



<a id="regularOreillyDetailedExplanation7073"></a>
#### 正規表現関連のPerlイズム

<a id="regularOreillyDetailedExplanation70731"></a>
##### 式のコンテキスト


<a id="regularOreillyDetailedExplanation70732"></a>
##### 動的スコープと正規表現マッチに対するその影響


<a id="regularOreillyDetailedExplanation70733"></a>
##### マッチによって書き換えられる特殊変数



<a id="regularOreillyDetailedExplanation7074"></a>
#### qr/…/演算子と正規表現オブジェクト

<a id="regularOreillyDetailedExplanation70741"></a>
##### 正規表現オブジェクトの作り方と使い方


<a id="regularOreillyDetailedExplanation70742"></a>
##### 正規表現オブジェクトの表示


<a id="regularOreillyDetailedExplanation70743"></a>
##### 効率向上のために正規表現オブジェクトを使う方法



<a id="regularOreillyDetailedExplanation7075"></a>
#### マッチ演算子

<a id="regularOreillyDetailedExplanation70751"></a>
##### マッチ演算子の正規表現被演算子


<a id="regularOreillyDetailedExplanation70752"></a>
##### マッチターゲット被演算子の指定方法


<a id="regularOreillyDetailedExplanation70753"></a>
##### マッチ演算子のさまざまな使い方


<a id="regularOreillyDetailedExplanation70754"></a>
##### 反復的なマッチ――/gありのスカラーコンテキスト


<a id="regularOreillyDetailedExplanation70755"></a>
##### マッチ演算子と環境との関係



<a id="regularOreillyDetailedExplanation7076"></a>
#### 置換演算子

<a id="regularOreillyDetailedExplanation70761"></a>
##### 置換被演算子


<a id="regularOreillyDetailedExplanation70762"></a>
##### /e修飾子


<a id="regularOreillyDetailedExplanation70763"></a>
##### コンテキストと戻り値



<a id="regularOreillyDetailedExplanation7077"></a>
#### split演算子

<a id="regularOreillyDetailedExplanation70771"></a>
##### splitの基本


<a id="regularOreillyDetailedExplanation70772"></a>
##### 空要素


<a id="regularOreillyDetailedExplanation70773"></a>
##### splitの特殊なマッチ被演算子


<a id="regularOreillyDetailedExplanation70774"></a>
##### キャプチャ付き括弧を含むsplitのマッチ被演算子



<a id="regularOreillyDetailedExplanation7078"></a>
#### Perlの拡張機能

<a id="regularOreillyDetailedExplanation70781"></a>
##### 動的正規表現を使って入れ子の対にマッチさせる


<a id="regularOreillyDetailedExplanation70782"></a>
##### 組み込みコードの使い方


<a id="regularOreillyDetailedExplanation70783"></a>
##### 組み込みコードでのlocalの使い方


<a id="regularOreillyDetailedExplanation70784"></a>
##### 組み込みコードとmy変数についての注意


<a id="regularOreillyDetailedExplanation70785"></a>
##### 組み込みコードを使った入れ子構造のマッチ


<a id="regularOreillyDetailedExplanation70786"></a>
##### 正規表現リテラルのオーバーロード


<a id="regularOreillyDetailedExplanation70787"></a>
##### 正規表現リテラルのオーバーロードに関する問題点


<a id="regularOreillyDetailedExplanation70788"></a>
##### 名前付きキャプチャの模倣



<a id="regularOreillyDetailedExplanation7079"></a>
#### Perlの効率性の問題

<a id="regularOreillyDetailedExplanation70791"></a>
##### やり方は1つではない


<a id="regularOreillyDetailedExplanation70792"></a>
##### 正規表現のコンパイルや/o修飾子、qr/…/と処理効率


<a id="regularOreillyDetailedExplanation70793"></a>
##### “プレマッチ”コピーの動作


<a id="regularOreillyDetailedExplanation70794"></a>
##### study関数


<a id="regularOreillyDetailedExplanation70795"></a>
##### ベンチマークテスト


<a id="regularOreillyDetailedExplanation70796"></a>
##### 正規表現のデバッグ情報



<a id="regularOreillyDetailedExplanation70710"></a>
#### 最後に言っておきたいこと



<a id="regularOreillyDetailedExplanation60000001"></a>
### 効率のよい正規表現の作り方

<a id="regularOreillyDetailedExplanation6061"></a>
#### 酔いも醒めるようなサンプル

<a id="regularOreillyDetailedExplanation60611"></a>
##### 簡単な変更――効き足を先に


<a id="regularOreillyDetailedExplanation60612"></a>
##### 効率と正しさ


<a id="regularOreillyDetailedExplanation60613"></a>
##### さらに改良――欲張りな動作の局所化


<a id="regularOreillyDetailedExplanation60614"></a>
##### 現実性のチェック



<a id="regularOreillyDetailedExplanation6062"></a>
#### バックトラックの全体像

<a id="regularOreillyDetailedExplanation60621"></a>
##### POSIX NFAの余分な仕事


<a id="regularOreillyDetailedExplanation60622"></a>
##### マッチ不成功のときに必要な仕事


<a id="regularOreillyDetailedExplanation60623"></a>
##### より厳密に


<a id="regularOreillyDetailedExplanation60624"></a>
##### 選択は高くつく場合がある



<a id="regularOreillyDetailedExplanation6063"></a>
#### ベンチマークテスト

<a id="regularOreillyDetailedExplanation60631"></a>
##### 何を計測しているのかを把握する


<a id="regularOreillyDetailedExplanation60632"></a>
##### PHPによるベンチマークテスト


<a id="regularOreillyDetailedExplanation60633"></a>
##### Javaによるベンチマークテスト


<a id="regularOreillyDetailedExplanation60634"></a>
##### VB.NETによるベンチマークテスト


<a id="regularOreillyDetailedExplanation60635"></a>
##### Rubyによるベンチマークテスト


<a id="regularOreillyDetailedExplanation60636"></a>
##### Pythonによるベンチマークテスト


<a id="regularOreillyDetailedExplanation60637"></a>
##### Tclによるベンチマークテスト



<a id="regularOreillyDetailedExplanation6064"></a>
#### よく見られる最適化

<a id="regularOreillyDetailedExplanation60641"></a>
##### タダでは手に入らない


<a id="regularOreillyDetailedExplanation60642"></a>
##### 実装による違い


<a id="regularOreillyDetailedExplanation60643"></a>
##### 正規表現適用のメカニズム


<a id="regularOreillyDetailedExplanation60644"></a>
##### 適用前の最適化


<a id="regularOreillyDetailedExplanation60645"></a>
##### トランスミッションの最適化


<a id="regularOreillyDetailedExplanation60646"></a>
##### 正規表現自体の最適化



<a id="regularOreillyDetailedExplanation6065"></a>
#### より高速な正規表現を書くためのテクニック

<a id="regularOreillyDetailedExplanation60651"></a>
##### 常識的なテクニック


<a id="regularOreillyDetailedExplanation60652"></a>
##### リテラルテキストを目立たせる


<a id="regularOreillyDetailedExplanation60653"></a>
##### アンカーを目立たせる


<a id="regularOreillyDetailedExplanation60654"></a>
##### 最小量指定子と最大量指定子の使い分け


<a id="regularOreillyDetailedExplanation60655"></a>
##### 複数の正規表現への分割


<a id="regularOreillyDetailedExplanation60656"></a>
##### 先頭文字の識別の模倣


<a id="regularOreillyDetailedExplanation60657"></a>
##### アトミックグループと絶対最大量指定子を使う


<a id="regularOreillyDetailedExplanation60658"></a>
##### エンジンをマッチに導く



<a id="regularOreillyDetailedExplanation6066"></a>
#### ループ展開

<a id="regularOreillyDetailedExplanation60661"></a>
##### 方法1：過去の経験に基づいて正規表現を組み立てる


<a id="regularOreillyDetailedExplanation60662"></a>
##### 本物の“ループ展開”パターン


<a id="regularOreillyDetailedExplanation60663"></a>
##### 方法2：トップダウンの視点


<a id="regularOreillyDetailedExplanation60664"></a>
##### 方法3：インターネットのホスト名


<a id="regularOreillyDetailedExplanation60665"></a>
##### 所見


<a id="regularOreillyDetailedExplanation60666"></a>
##### アトミックグループや絶対最大量指定子を使った方法


<a id="regularOreillyDetailedExplanation60667"></a>
##### ループ展開の簡単なサンプル


<a id="regularOreillyDetailedExplanation60668"></a>
##### Cコメントのループ展開



<a id="regularOreillyDetailedExplanation6067"></a>
#### スムーズに流れる正規表現

<a id="regularOreillyDetailedExplanation60671"></a>
##### マッチを導く救いの手


<a id="regularOreillyDetailedExplanation60672"></a>
##### 正規表現を適切な方向に導いて高速化する


<a id="regularOreillyDetailedExplanation60673"></a>
##### 最後に



<a id="regularOreillyDetailedExplanation6068"></a>
#### まとめ：考えよ！



<a id="regularOreillyDetailedExplanation50000001"></a>
### 正規表現の実践的なテクニック

<a id="regularOreillyDetailedExplanation5051"></a>
#### 正規表現の平衡感覚


<a id="regularOreillyDetailedExplanation5052"></a>
#### 短めのサンプル

<a id="regularOreillyDetailedExplanation50521"></a>
##### 継続行の継続


<a id="regularOreillyDetailedExplanation50522"></a>
##### IPアドレスへのマッチ


<a id="regularOreillyDetailedExplanation50523"></a>
##### ファイル名の操作


<a id="regularOreillyDetailedExplanation50524"></a>
##### 括弧類の対へのマッチ


<a id="regularOreillyDetailedExplanation50525"></a>
##### 望ましくないマッチを減らすには


<a id="regularOreillyDetailedExplanation50526"></a>
##### 区切り子の入ったテキストへのマッチ


<a id="regularOreillyDetailedExplanation50527"></a>
##### データの知識を活用して前提条件を意識する


<a id="regularOreillyDetailedExplanation50528"></a>
##### 先頭や末尾の空白の除去



<a id="regularOreillyDetailedExplanation5053"></a>
#### HTML関連のサンプル

<a id="regularOreillyDetailedExplanation50531"></a>
##### HTMLタグへのマッチ


<a id="regularOreillyDetailedExplanation50532"></a>
##### HTMLリンクへのマッチ


<a id="regularOreillyDetailedExplanation50533"></a>
##### HTTP URLの解析


<a id="regularOreillyDetailedExplanation50534"></a>
##### ホスト名のチェック


<a id="regularOreillyDetailedExplanation50535"></a>
##### URLを抽出する実用的なコード



<a id="regularOreillyDetailedExplanation5054"></a>
#### 高度なサンプル

<a id="regularOreillyDetailedExplanation50541"></a>
##### データとの同期の確保


<a id="regularOreillyDetailedExplanation50542"></a>
##### CSVファイルの走査




<a id="regularOreillyDetailedExplanation40000001"></a>
### 正規表現処理のメカニズム

<a id="regularOreillyDetailedExplanation4041"></a>
#### エンジン始動

<a id="regularOreillyDetailedExplanation40411"></a>
##### 2種類のエンジン


<a id="regularOreillyDetailedExplanation40412"></a>
##### 新基準


<a id="regularOreillyDetailedExplanation40413"></a>
##### 正規表現エンジンのタイプ


<a id="regularOreillyDetailedExplanation40414"></a>
##### 合衆国冗長省からの要請


<a id="regularOreillyDetailedExplanation40415"></a>
##### エンジンのタイプのテスト



<a id="regularOreillyDetailedExplanation4042"></a>
#### マッチの基本原則

<a id="regularOreillyDetailedExplanation40421"></a>
##### サンプルについて


<a id="regularOreillyDetailedExplanation40422"></a>
##### 原則1：最初にマッチしたものが優先される


<a id="regularOreillyDetailedExplanation40423"></a>
##### エンジンの部品


<a id="regularOreillyDetailedExplanation40424"></a>
##### 原則2：標準の量指定子は欲張りである



<a id="regularOreillyDetailedExplanation4043"></a>
#### 正規表現主導かテキスト主導か

<a id="regularOreillyDetailedExplanation40431"></a>
##### 正規表現主導型のNFAエンジン


<a id="regularOreillyDetailedExplanation40432"></a>
##### テキスト主導型のDFAエンジン


<a id="regularOreillyDetailedExplanation40433"></a>
##### NFAとDFAの比較：最初の考察



<a id="regularOreillyDetailedExplanation4044"></a>
#### バックトラック

<a id="regularOreillyDetailedExplanation40441"></a>
##### パン切れのたとえ


<a id="regularOreillyDetailedExplanation40442"></a>
##### バックトラックに関する2つの重要なポイント


<a id="regularOreillyDetailedExplanation40443"></a>
##### 保存ステート


<a id="regularOreillyDetailedExplanation40444"></a>
##### バックトラックと欲張り度



<a id="regularOreillyDetailedExplanation4045"></a>
#### さらに、欲張りなこととバックトラックについて

<a id="regularOreillyDetailedExplanation40451"></a>
##### 欲張りな動作の問題点


<a id="regularOreillyDetailedExplanation40452"></a>
##### 複数の文字による“クォート”


<a id="regularOreillyDetailedExplanation40453"></a>
##### 控え目な量指定子の使い方


<a id="regularOreillyDetailedExplanation40454"></a>
##### 欲張りでも控え目でも常にマッチ優先


<a id="regularOreillyDetailedExplanation40455"></a>
##### 欲張り、控え目、バックトラックの本質


<a id="regularOreillyDetailedExplanation40456"></a>
##### 絶対最大量指定子とアトミックグループ


<a id="regularOreillyDetailedExplanation40457"></a>
##### 絶対最大量指定子：?+、\*+、++、{m,n}+


<a id="regularOreillyDetailedExplanation40458"></a>
##### 先後読みのバックトラック


<a id="regularOreillyDetailedExplanation40459"></a>
##### 選択は欲張りか


<a id="regularOreillyDetailedExplanation404510"></a>
##### 早い者勝ち選択の活用方法



<a id="regularOreillyDetailedExplanation4046"></a>
#### NFA、DFA、POSIX

<a id="regularOreillyDetailedExplanation40461"></a>
##### 最左最長


<a id="regularOreillyDetailedExplanation40462"></a>
##### POSIXと最左最長原則


<a id="regularOreillyDetailedExplanation40463"></a>
##### スピードと効率


<a id="regularOreillyDetailedExplanation40464"></a>
##### NFAとDFAの比較：まとめ



<a id="regularOreillyDetailedExplanation4047"></a>
#### まとめ



<a id="regularOreillyDetailedExplanation30000001"></a>
### 正規表現の機能と方言

<a id="regularOreillyDetailedExplanation3031"></a>
#### 正規表現のスケッチ

<a id="regularOreillyDetailedExplanation30311"></a>
##### 正規表現の起源


<a id="regularOreillyDetailedExplanation30312"></a>
##### 一見してわかる違い



<a id="regularOreillyDetailedExplanation3032"></a>
#### 正規表現処理のインタフェース

<a id="regularOreillyDetailedExplanation30321"></a>
##### 統合型インタフェース


<a id="regularOreillyDetailedExplanation30322"></a>
##### 手続き型、オブジェクト指向型インタフェース


<a id="regularOreillyDetailedExplanation30323"></a>
##### 置換のサンプル


<a id="regularOreillyDetailedExplanation30324"></a>
##### その他の言語による置換


<a id="regularOreillyDetailedExplanation30325"></a>
##### インタフェースのまとめ



<a id="regularOreillyDetailedExplanation3033"></a>
#### 文字列、コード体系、モード

<a id="regularOreillyDetailedExplanation30331"></a>
##### 正規表現を表す文字列


<a id="regularOreillyDetailedExplanation30332"></a>
##### コード体系の問題


<a id="regularOreillyDetailedExplanation30333"></a>
##### Unicode


<a id="regularOreillyDetailedExplanation30334"></a>
##### 正規表現モードとマッチモード



<a id="regularOreillyDetailedExplanation3034"></a>
#### よく使われるメタ文字とその機能

<a id="regularOreillyDetailedExplanation30341"></a>
##### 文字の表現


<a id="regularOreillyDetailedExplanation30342"></a>
##### 文字クラスと文字クラス的な構文


<a id="regularOreillyDetailedExplanation30343"></a>
##### アンカーなどの“ゼロ幅マッチ”


<a id="regularOreillyDetailedExplanation30344"></a>
##### コメントとモード修飾子


<a id="regularOreillyDetailedExplanation30345"></a>
##### グループ化、キャプチャ、条件分岐、制御構造



<a id="regularOreillyDetailedExplanation3035"></a>
#### 高度な内容を扱う章に進むための指針



<a id="regularOreillyDetailedExplanation20000001"></a>
### 初心者向けのサンプル

<a id="regularOreillyDetailedExplanation2021"></a>
#### サンプルについて

<a id="regularOreillyDetailedExplanation20211"></a>
##### Perlの簡単な解説



<a id="regularOreillyDetailedExplanation2022"></a>
#### 正規表現をテキストにマッチさせる

<a id="regularOreillyDetailedExplanation20221"></a>
##### もっと本格的に


<a id="regularOreillyDetailedExplanation20222"></a>
##### マッチが成功したときの副作用


<a id="regularOreillyDetailedExplanation20223"></a>
##### 入り組んだ正規表現


<a id="regularOreillyDetailedExplanation20224"></a>
##### 中締め



<a id="regularOreillyDetailedExplanation2023"></a>
#### 正規表現によるテキストの書き換え


<a id="regularOreillyDetailedExplanation20231"></a>
##### サンプル：ダイレクトメール


<a id="regularOreillyDetailedExplanation20232"></a>
##### サンプル：株価表示の整形


<a id="regularOreillyDetailedExplanation20233"></a>
##### 自動編集


<a id="regularOreillyDetailedExplanation20234"></a>
##### ささやかなメールユーティリティ


<a id="regularOreillyDetailedExplanation20235"></a>
##### 先後読みによって数値にカンマを付け加える


<a id="regularOreillyDetailedExplanation20236"></a>
##### テキストからHTMLへの変換


<a id="regularOreillyDetailedExplanation20237"></a>
##### 語の重複問題再説



<a id="regularOreillyDetailedExplanation10000001"></a>
### 正規表現入門

<a id="regularOreillyDetailedExplanation1011"></a>
#### 現実の問題を解決するために


<a id="regularOreillyDetailedExplanation1012"></a>
#### 言語としての正規表現

<a id="regularOreillyDetailedExplanation10121"></a>
##### ファイル名との類似点


<a id="regularOreillyDetailedExplanation10122"></a>
##### 言語との類似点


<a id="regularOreillyDetailedExplanation1013"></a>
#### 正規表現という思考の枠組み

<a id="regularOreillyDetailedExplanation10131"></a>
##### ある程度正規表現のことを知っているなら


<a id="regularOreillyDetailedExplanation10132"></a>
##### ファイルからのテキストの検索：egrep



<a id="regularOreillyDetailedExplanation1014"></a>
#### egrepのメタ文字

<a id="regularOreillyDetailedExplanation10141"></a>
##### 行頭と行末


<a id="regularOreillyDetailedExplanation10142"></a>
##### 文字クラス


<a id="regularOreillyDetailedExplanation10143"></a>
##### 任意の文字にマッチするドット


<a id="regularOreillyDetailedExplanation10144"></a>
##### 選択


<a id="regularOreillyDetailedExplanation10145"></a>
##### 大文字と小文字の違いを無視する


<a id="regularOreillyDetailedExplanation10146"></a>
##### 単語の境界


<a id="regularOreillyDetailedExplanation10147"></a>
##### これまでのまとめ


<a id="regularOreillyDetailedExplanation10148"></a>
##### 量指定子：オプション


<a id="regularOreillyDetailedExplanation10149"></a>
##### その他の量指定子：繰り返し


<a id="regularOreillyDetailedExplanation101410"></a>
##### 括弧と後方参照


<a id="regularOreillyDetailedExplanation101411"></a>
##### 大脱走――偉大なるエスケープ



<a id="regularOreillyDetailedExplanation1015"></a>
#### 基礎を発展させる

<a id="regularOreillyDetailedExplanation10151"></a>
##### 言語の多様性


<a id="regularOreillyDetailedExplanation10152"></a>
##### 正規表現の目的


<a id="regularOreillyDetailedExplanation10153"></a>
##### 実例をもっと


<a id="regularOreillyDetailedExplanation10154"></a>
##### 正規表現の用語


<a id="regularOreillyDetailedExplanation10155"></a>
##### 現状の打破


<a id="regularOreillyDetailedExplanation10156"></a>
##### まとめ



<a id="regularOreillyDetailedExplanation1016"></a>
#### 章の終わりに一言


<a id="regularOreillyDetailedExplanation00000001"></a>
### はじめに

<a id="memo2999"></a>
### 個人メモ

---
<a id="shoeisha9784798156422"></a>
## 書籍：**正規表現辞典 改訂新版**

<a id="regularDesktopReference9000001"></a>
### APPENDIX

<a id="regularDesktopReference9AP0100"></a>
#### ASCII

<a id="regularDesktopReference9APAP0101"></a>
#### ASCIIの制御文字一覧

<a id="regularDesktopReference9APAPAP0200"></a>
#### Unicode

<a id="regularDesktopReference9APAPAPAP0201"></a>
#### Unicode 一般カテゴリ一覧

<a id="regularDesktopReference6000001"></a>
### 逆引きリファレンス 置換編

<a id="regularDesktopReference6060000"></a>
#### 置換編イントロダクション

<a id="regularDesktopReference6060000"></a>
#### 置換編での正規表現について

<a id="regularDesktopReference6060100"></a>
#### 文書作成

<a id="regularDesktopReference6060101"></a>
#### 行と行の間に空行を追加したい
`s/$/\n/`  

##### 空行検索及び置換
置換前に、そもそも空行を検索する方法を勉強する。  
そして、検索語に置き換えることの勉強に手を出す。  

以下、言語ごとの細かい方言(違い)を説明する。  
* 一覧  
  * [Vim](#regularDesktopReferenceVim6060101)  
  * [秀丸エディタ](#regularDesktopReferenceHidemaru6060101)  
  * [サクラエディタ](#regularDesktopReferenceSakura6060101)  
  * [grep](#regularDesktopReferenceGrep6060101)  
  * [Perl](#regularDesktopReferencePerl6060101)  

<a name="regularDesktopReferenceVim6060101"></a>
###### Vim
* 検索作業。  
検索用テキスト。
```terminal
$ cat -n serch.txt
     1  aaa
     2
     3  bbb
     4
     5  ccc
     6
$
```
※2・4・6行目は、空行になっている(下記の検索コマンドで、この3行がヒットする)。  

検索コマンド：
`^$`  
あぁ・・・。  
検索コマンド：
`^\n`  
あぁ・・・。  

ちなみに、`\r`では検索に掛からなかった。  

verymagic検索コマンド：
`\v^\n`  

verymagic検索コマンド：
`\v^$`  


* 置換作業。  
実行前のテキスト
```text
aaa
bbb
ccc
```

改行挿入コマンド：
`%s/$/\r/g`  

実行後のテキスト
```text
aaa

bbb

ccc

```
`\n`と思っていたが、`\r`で改行を表すようだ。  
なぜ？  

<a name="regularDesktopReferenceHidemaru6060101"></a>
###### 秀丸エディタ

<a name="regularDesktopReferenceSakura6060101"></a>
###### サクラエディタ

<a name="regularDesktopReferenceGrep6060101"></a>
###### grep

<a name="regularDesktopReferencePerl6060101"></a>
###### Perl

<a id="regularDesktopReference6060102"></a>
#### 文の区切りで改行を入れたい

<a id="regularDesktopReference6060103"></a>
#### 行の先頭及び末尾の空白を削除したい

<a id="regularDesktopReference6060104"></a>
#### カンマの後ろのスペースを1つに統一したい

<a id="regularDesktopReference6060105"></a>
#### ピリオドの後ろのスペースを2つに統一したい

<a id="regularDesktopReference6060106"></a>
#### 段落を保持したまま複数行を1行にしたい

<a id="regularDesktopReference6060107"></a>
#### 英数字 / 英単語と日本語の文字の間にスペースを挾みたい

<a id="regularDesktopReference6060108"></a>
#### 単語の先頭の文字を大文字に変換したい

<a id="regularDesktopReference6060109"></a>
#### 各単語の先頭1文字から頭字語を作成したい

<a id="regularDesktopReference6060200"></a>
#### HTML/XML

<a id="regularDesktopReference6060201"></a>
#### 「sample.html#p1」から、#より前 / 後の文字列を削除したい

<a id="regularDesktopReference6060202"></a>
#### 「&」をすべて「&」に置換したい

<a id="regularDesktopReference6060203"></a>
#### XMLの「<要素名/>」を「<要素名>」に変換したい

<a id="regularDesktopReference6060204"></a>
#### タグの外部にある「green」をすべて「yellow」に変換したい

<a id="regularDesktopReference6060205"></a>
#### HTML/XMLのコメントを削除したい

<a id="regularDesktopReference6060300"></a>
#### プログラミング

<a id="regularDesktopReference6060301"></a>
#### クエリ文字列から値が入っていないフォームデータを排除したい

<a id="regularDesktopReference6060302"></a>
#### 「product\_name」を「productName」に変換したい

<a id="regularDesktopReference6060303"></a>
#### 「PRODUCT\_NAME」を「productName」に変換したい

<a id="regularDesktopReference6060304"></a>
#### メールの引用符を取り除きたい

<a id="regularDesktopReference6060305"></a>
#### ファイル名から拡張子を除去したい

<a id="regularDesktopReference6060306"></a>
#### パス名からファイル名部分以外を除去したい

<a id="regularDesktopReference6060400"></a>
#### プログラム解析

<a id="regularDesktopReference6060401"></a>
#### Javaプログラムからコメントを削除したい

<a id="regularDesktopReference6060402"></a>
#### Perlプログラムからコメントを削除したい

<a id="regularDesktopReference6060403"></a>
#### Cプログラムからコメントを削除したい

<a id="regularDesktopReference5000001"></a>
### 逆引きリファレンス 応用編

<a id="regularDesktopReference5050000"></a>
#### 応用編イントロダクション

<a id="regularDesktopReference5050000"></a>
#### 応用編での正規表現について

<a id="regularDesktopReference5050100"></a>
#### 一般

<a id="regularDesktopReference505"></a>
#### 空白しかない行にマッチさせたい

<a id="regularDesktopReference505"></a>
#### まったく同じ文字 / 単語が連続する部分にマッチさせたい

<a id="regularDesktopReference505"></a>
#### 文字列「abc」から始まらない行にマッチさせたい

<a id="regularDesktopReference505"></a>
#### 文字列「abc」が含まれない行にマッチさせたい

<a id="regularDesktopReference505"></a>
#### 大文字が3文字以上連続した単語にマッチさせたい

<a id="regularDesktopReference505"></a>
#### ダブルクォートで括られた文字列にマッチさせたい

<a id="regularDesktopReference505"></a>
#### 小数にマッチさせたい

<a id="regularDesktopReference505"></a>
#### 指数表記の数値にマッチさせたい

<a id="regularDesktopReference505"></a>
#### 3桁区切りの数値にマッチさせたい

<a id="regularDesktopReference5050200"></a>
#### HTML/XML

<a id="regularDesktopReference5050201"></a>
#### URLにマッチさせたい

<a id="regularDesktopReference5050202"></a>
#### HTML内の色指定にマッチさせたい

<a id="regularDesktopReference5050203"></a>
#### HTMLのa要素からhref属性の値を抜き出したい

<a id="regularDesktopReference5050204"></a>
#### HTMLの見出し要素の内容を抜き出したい

<a id="regularDesktopReference5050205"></a>
#### HTML/XMLの開始タグにマッチさせたい

<a id="regularDesktopReference5050206"></a>
#### type属性がhidden以外のinput要素にマッチさせたい

<a id="regularDesktopReference5050300"></a>
#### 日付 / 時刻

<a id="regularDesktopReference5050301"></a>
#### 年月日の表記にマッチさせたい

<a id="regularDesktopReference5050302"></a>
#### 「19:58:02」形式にマッチさせたい

<a id="regularDesktopReference5050400"></a>
#### プログラミング

<a id="regularDesktopReference5050401"></a>
#### 郵便番号にマッチさせたい

<a id="regularDesktopReference5050402"></a>
#### 電話番号にマッチさせたい

<a id="regularDesktopReference5050403"></a>
#### 「キー=値」という形式にマッチさせたい

<a id="regularDesktopReference5050404"></a>
#### Windowsのフルパス形式にマッチさせたい

<a id="regularDesktopReference5050405"></a>
#### Windowsの特殊ファイル名にマッチさせたい

<a id="regularDesktopReference5050406"></a>
#### IPアドレス（IPv4）にマッチさせたい

<a id="regularDesktopReference5050407"></a>
#### ホスト名（FQDN）にマッチさせたい

<a id="regularDesktopReference5050408"></a>
#### パーセントエンコーディングにマッチさせたい

<a id="regularDesktopReference5050409"></a>
#### エンコードされたメールヘッダにマッチさせたい

<a id="regularDesktopReference5050410"></a>
#### クエリ文字列を分解したい

<a id="regularDesktopReference5050411"></a>
#### メールアドレスにマッチさせたい

<a id="regularDesktopReference5050500"></a>
#### プログラム解析

<a id="regularDesktopReference5050501"></a>
#### Cプログラムからインクルードされたファイルを抜き出したい

<a id="regularDesktopReference5050502"></a>
#### スクリプトからヒア・ドキュメントを抜き出したい

<a id="regularDesktopReference4000001"></a>
### 逆引きリファレンス 基本編

<a id="regularDesktopReference4040100"></a>
#### 基本

<a id="regularDesktopReference4040101"></a>
#### 文字「a」が連続している部分にマッチさせたい

<a id="regularDesktopReference4040102"></a>
#### 「a」が5回続いた文字列にマッチさせたい

<a id="regularDesktopReference4040103"></a>
#### 「Java SE」あるいは「JavaSE」にマッチさせたい

<a id="regularDesktopReference4040104"></a>
#### 「boy」あるいは「girl」にマッチさせたい

<a id="regularDesktopReference4040105"></a>
#### 「.」そのものにマッチさせたい

<a id="regularDesktopReference4040106"></a>
#### ある文字列から始まる行にマッチさせたい

<a id="regularDesktopReference4040107"></a>
#### ある文字列で終わる行にマッチさせたい

<a id="regularDesktopReference4040108"></a>
#### 文字列の先頭 / 末尾にマッチさせたい

<a id="regularDesktopReference4040109"></a>
#### 英数字にマッチさせたい

<a id="regularDesktopReference4040110"></a>
#### 数字にマッチさせたい

<a id="regularDesktopReference4040111"></a>
#### 空白にマッチさせたい

<a id="regularDesktopReference4040112"></a>
#### 「book」という単語そのものにマッチさせたい

<a id="regularDesktopReference4040113"></a>
#### 任意の単語にマッチさせたい

<a id="regularDesktopReference4040114"></a>
#### コード値で文字を指定したい

<a id="regularDesktopReference4040115"></a>
#### 制御文字にマッチさせたい

<a id="regularDesktopReference4040116"></a>
#### 大文字と小文字を区別せずにマッチさせたい

<a id="regularDesktopReference4040117"></a>
#### 「a」以外の1文字にマッチさせたい

<a id="regularDesktopReference4040118"></a>
#### 「c」と「x」を除くアルファベット小文字にマッチさせたい

<a id="regularDesktopReference4040119"></a>
#### 最初に現れる「/」までにマッチさせたい

<a id="regularDesktopReference4040120"></a>
#### 指定したパターンが繰り返し登場するかどうかを調べたい

<a id="regularDesktopReference4040121"></a>
#### 「Japan」にはマッチするが「Japanese」にはマッチしない

<a id="regularDesktopReference4040122"></a>
#### 「社長」にはマッチするが「副社長」にはマッチしない

<a id="regularDesktopReference4040123"></a>
#### ひらがな / カタカナ / 漢字にマッチさせたい

<a id="regularDesktopReference3000001"></a>
### メタキャラクタリファレンス

<a id="regularDesktopReference3030100"></a>
#### 基本正規表現

<a id="regularDesktopReference3030101"></a>
#### x 「その文字」自身にマッチ

<a id="regularDesktopReference3030102"></a>
#### \ メタキャラクタの持つ特別な意味を失わせる

<a id="regularDesktopReference3030103"></a>
#### . 任意の1文字にマッチ

<a id="regularDesktopReference3030104"></a>
#### [xyz] 指定された文字の中のいずれかにマッチ

<a id="regularDesktopReference3030105"></a>
#### (pattern)、\(pattern\) 部分正規表現のグルーピング

<a id="regularDesktopReference3030106"></a>
#### * 直前の正規表現と0回以上一致

<a id="regularDesktopReference3030107"></a>
#### {min,max}、\{min,max\} 直前の正規表現と指定回数一致

<a id="regularDesktopReference3030108"></a>
#### $ 文字列の末尾、または行終端子の直前にマッチ
`$`は、文字列の末尾や行終端子(`\r`・`\n`・`\r\n`)ではなく、その直前の空文字を表す。  
Vimの場合は、この挙動をせずに、独自の動きをする。  



<a id="regularDesktopReference3030109"></a>
#### ^ 文字列の先頭、または行終端子の直後にマッチ

<a id="regularDesktopReference3030110"></a>
#### \n キャプチャ済みの部分正規表現に対する後方参照

<a id="regularDesktopReference3030111"></a>
#### [:..:] POSIX文字クラス表現

<a id="regularDesktopReference3030112"></a>
#### [.ll.] 指定した照合要素にマッチ

<a id="regularDesktopReference3030113"></a>
#### [=e=] 指定した等価クラスに含まれる文字にマッチ

<a id="regularDesktopReference3030200"></a>
#### 拡張正規表現

<a id="regularDesktopReference3030201"></a>
#### x¦y、x\¦y 正規表現xまたはyにマッチ

<a id="regularDesktopReference3030202"></a>
#### +、\+ 直前の正規表現と1回以上一致

<a id="regularDesktopReference3030203"></a>
#### ?、\?、\= 直前の正規表現と0回または1回一致

<a id="regularDesktopReference3030300"></a>
#### 文字クラスエスケープ

<a id="regularDesktopReference3030301"></a>
#### \d、\D 任意の数字にマッチ / 数字以外の任意の1 字にマッチ

<a id="regularDesktopReference3030302"></a>
#### \s、\S 任意の空白にマッチ / 空白以外の任意の文字にマッチ

<a id="regularDesktopReference3030303"></a>
#### \w、\W 任意の単語構成文字にマッチ / 単語構成文字以外の任意の文字にマッチ

<a id="regularDesktopReference3030304"></a>
#### v、\V 任意の垂直方向の空白にマッチ / 垂直方向の空白以外の任意の1 字にマッチ

<a id="regularDesktopReference3030305"></a>
#### \h、\H 任意の水平方向の空白にマッチ / 水平方向の空白以外の任意の1 字にマッチ

<a id="regularDesktopReference3030400"></a>
#### 制御文字とUnicode

<a id="regularDesktopReference3030401"></a>
#### \n、\a、\b、\e、\f、\r、\t 各種の制御文字にマッチ

<a id="regularDesktopReference3030402"></a>
#### \cx xで指定した制御文字にマッチ

<a id="regularDesktopReference3030403"></a>
#### \nnn、\onnn nnnに指定した8進表現で示される文字にマッチ

<a id="regularDesktopReference3030404"></a>
#### \xnn nに指定した16進表現で示される文字にマッチ

<a id="regularDesktopReference3030405"></a>
#### \unnnn、\x{n} nに指定したコードポイントで表現される文字にマッチ

<a id="regularDesktopReference3030406"></a>
#### \p{...}、\P{...} Unicodeプロパティに基づく条件に合致する文字にマッチ

<a id="regularDesktopReference3030407"></a>
#### \N{...} 正式なUnicode文字名で表現される文字にマッチ

<a id="regularDesktopReference3030408"></a>
#### \x Unicodeの書記素クラスタにマッチ

<a id="regularDesktopReference3030500"></a>
#### 特殊な量指定子

<a id="regularDesktopReference3030501"></a>
#### *?、\{-} 直前の正規表現と0回以上一致（最短一致）

<a id="regularDesktopReference3030502"></a>
#### {min,max}?、\{-min,max} 直前の正規表現と指定回数一致（最短一致）

<a id="regularDesktopReference3030503"></a>
#### +? 直前の正規表現と1回以上一致（最短一致）

<a id="regularDesktopReference3030504"></a>
#### ?? 直前の正規表現と0回または1回一致（最短一致）

<a id="regularDesktopReference3030505"></a>
#### \*+ 直前の正規表現と0回以上一致（強欲）

<a id="regularDesktopReference3030506"></a>
#### {min,max}+ 直前の正規表現と指定回数一致（強欲）

<a id="regularDesktopReference3030507"></a>
#### ++ 直前の正規表現と1回以上一致（強欲）

<a id="regularDesktopReference3030508"></a>
#### ?+ 直前の正規表現と0回または1回一致（強欲）

<a id="regularDesktopReference3030600"></a>
#### アンカー

<a id="regularDesktopReference3030601"></a>
#### \b、\B 単語の境界にマッチ / 単語の境界以外にマッチ

<a id="regularDesktopReference3030602"></a>
#### \<、\> 単語の先頭にマッチ / 単語の末尾にマッチ

<a id="regularDesktopReference3030603"></a>
#### \A 文字列の先頭にマッチ

<a id="regularDesktopReference3030604"></a>
#### \Z 文字列の末尾、あるいは文字列の末尾の行終端子の直前にマッチ

<a id="regularDesktopReference3030605"></a>
#### \z 文字列の末尾にマッチ

<a id="regularDesktopReference3030606"></a>
#### \G 前回のマッチの末尾にマッチ

<a id="regularDesktopReference3030607"></a>
#### \b{X} Unicodeの書記素クラスタ / 単語 / 文の境界にマッチ

<a id="regularDesktopReference3030700"></a>
#### グループ化構成体

<a id="regularDesktopReference3030701"></a>
#### (?:pattern) 部分正規表現のグルーピング（キャプチャなし）

<a id="regularDesktopReference3030702"></a>
#### (?=pattern) patternがこの位置の右に存在する場合にマッチ（肯定先読み）

<a id="regularDesktopReference3030703"></a>
#### (?!pattern) patternがこの位置の右に存在しない場合にマッチ（否定先読み）

<a id="regularDesktopReference3030704"></a>
#### (?<=pattern) patternがこの位置の左に存在する場合にマッチ（肯定戻り読み）

<a id="regularDesktopReference3030705"></a>
#### (? 03-07-06　(?>pattern) マッチ文字列に対するバックトラックを禁止する

<a id="regularDesktopReference3030707"></a>
#### (?(condition)yes-pattern) conditionが成立した場合は、yes-patternにマッチするかどうかを試す

<a id="regularDesktopReference3030708"></a>
#### (?Ppattern)、(?pattern) 名前付きキャプチャ

<a id="regularDesktopReference3030800"></a>
#### 修飾子

<a id="regularDesktopReference3030801"></a>
#### i修飾子 大文字 / 小文字の違いを無視する

<a id="regularDesktopReference3030802"></a>
#### c修飾子 マッチに失敗しても、前回のマッチ位置をリセットしない

<a id="regularDesktopReference3030803"></a>
#### d修飾子 UNIXラインモードにする

<a id="regularDesktopReference3030804"></a>
#### e修飾子 置換文字列をPerlコードとして評価し、その結果を利用する

<a id="regularDesktopReference3030805"></a>
#### g修飾子 繰り返しマッチを行う

<a id="regularDesktopReference3030806"></a>
#### m修飾子 マルチラインモードにする

<a id="regularDesktopReference3030807"></a>
#### o修飾子 正規表現を1回だけコンパイルする

<a id="regularDesktopReference3030808"></a>
#### s修飾子 シングルラインモードにする

<a id="regularDesktopReference3030809"></a>
#### u修飾子 Unicodeサポートの強化

<a id="regularDesktopReference3030810"></a>
#### x修飾子 パターン内で空白とコメントが利用可能となる

<a id="regularDesktopReference3030811"></a>
#### A修飾子 強制的に文字列先頭にマッチさせる

<a id="regularDesktopReference3030812"></a>
#### D修飾子 「$」を文字列の末尾にのみマッチさせる

<a id="regularDesktopReference3030813"></a>
#### U修飾子 「欲張り」と「無欲」の役割を反転させる(PHP)、文字クラスのマッチ対象をUnicodeベースにする(Java)

<a id="regularDesktopReference3030814"></a>
#### X修飾子 PCREの付加機能を有効にする

<a id="regularDesktopReference3030815"></a>
#### CANON\_EQフラグ 等価とみなされる文字を同じ文字としてマッチ

<a id="regularDesktopReference3030816"></a>
#### (?modifier)、(?-modifier) これ以降、指定した処理モードを利用する

<a id="regularDesktopReference3030817"></a>
#### (?modifier:pattern)、(?-modifier:pattern) 指定した処理モードを部分正規表現に適用する（クロイスタ）

<a id="regularDesktopReference3030818"></a>
#### y修飾子 前回のマッチ位置の直後にしかマッチさせない

<a id="regularDesktopReference3030819"></a>
#### a修飾子 ASCII文字のみのマッチングを行う

<a id="regularDesktopReference3030820"></a>
#### n修飾子 名前付きキャプチャのみをキャプチャする

<a id="regularDesktopReference3030900"></a>
#### 変換とエスケープ

<a id="regularDesktopReference303"></a>
#### \l、\u 次の文字を小文字/ 大文字として扱う

<a id="regularDesktopReference303"></a>
#### \Q ～\E 範囲内のすべての文字をエスケープする

<a id="regularDesktopReference303"></a>
#### \L ～\E、\U ～\E 範囲内のすべての文字を小文字/ 大文字として扱う

<a id="regularDesktopReference3031000"></a>
#### その他

<a id="regularDesktopReference3031001"></a>
#### (?# comment) 正規表現中のコメント

<a id="regularDesktopReference3031002"></a>
#### (?{code}) 埋め込まれたコードを実行する

<a id="regularDesktopReference3031003"></a>
#### (??{code}) 埋め込まれたコードを実行し、その結果を正規表現として使用

<a id="regularDesktopReference3031004"></a>
#### [a-z&&[bc]] ブラケット表現内での集合演算

<a id="regularDesktopReference3031005"></a>
#### vim 独自の文字クラス

<a id="regularDesktopReference3031006"></a>
#### vim 独自の文字クラスエスケープ

<a id="regularDesktopReference3031007"></a>
#### \& 両方の選択肢にマッチした場合のみマッチ

<a id="regularDesktopReference3031008"></a>
#### & マッチした内容に対する後方参照

<a id="regularDesktopReference3031009"></a>
#### \R、\N 各種の改行にマッチ / 改行以外の文字にマッチ

<a id="regularDesktopReference3031010"></a>
#### vim 独自のメタキャラクタ

<a id="regularDesktopReference2000001"></a>
### 処理系リファレンス

<a id="regularDesktopReference2020100"></a>
#### grep / egrep

<a id="regularDesktopReference2020101"></a>
#### 文字列を検索する

<a id="regularDesktopReference2020200"></a>
#### sed

<a id="regularDesktopReference2020201"></a>
#### 処理対象行を指定する

<a id="regularDesktopReference2020202"></a>
#### 指定した文字列を置換する（s コマンド）

<a id="regularDesktopReference2020300"></a>
#### awk

<a id="regularDesktopReference2020301"></a>
#### 指定した文字列を置換する

<a id="regularDesktopReference2020302"></a>
#### 文字列に対するマッチを行う

<a id="regularDesktopReference2020303"></a>
#### 処理対象レコードを指定する

<a id="regularDesktopReference2020400"></a>
#### vim

<a id="regularDesktopReference2020401"></a>
#### 文字列を検索する

<a id="regularDesktopReference2020402"></a>
#### 文字列を置換する

<a id="regularDesktopReference2020500"></a>
#### Perl

<a id="regularDesktopReference2020501"></a>
#### 文字列に対するマッチを行う

<a id="regularDesktopReference2020502"></a>
#### 正規表現オペランド / オブジェクトを作成

<a id="regularDesktopReference2020503"></a>
#### 文字列を置換する

<a id="regularDesktopReference2020600"></a>
#### PHP

<a id="regularDesktopReference2020601"></a>
#### 文字列を検索する

<a id="regularDesktopReference2020602"></a>
#### 配列から文字列を検索する

<a id="regularDesktopReference2020603"></a>
#### 正規表現全体をエスケープする

<a id="regularDesktopReference2020604"></a>
#### 文字列を置換する

<a id="regularDesktopReference2020700"></a>
#### Java

<a id="regularDesktopReference2020701"></a>
#### 正規表現オブジェクトを生成する

<a id="regularDesktopReference2020702"></a>
#### 文字列に対するマッチを行う

<a id="regularDesktopReference2020703"></a>
#### マッチした内容を取り出す

<a id="regularDesktopReference2020704"></a>
#### 文字列の置換を行う

<a id="regularDesktopReference2020800"></a>
#### JavaScript

<a id="regularDesktopReference2020801"></a>
#### RegExp オブジェクトの生成

<a id="regularDesktopReference2020802"></a>
#### 文字列に対するマッチを行う

<a id="regularDesktopReference2020803"></a>
#### 文字列の置換を行う

<a id="regularDesktopReference2020900"></a>
#### Python

<a id="regularDesktopReference2020901"></a>
#### 正規表現オブジェクトを生成する

<a id="regularDesktopReference2020902"></a>
#### 文字列に対するマッチを行う

<a id="regularDesktopReference2020903"></a>
#### 文字列の置換を行う

<a id="regularDesktopReference2021000"></a>
#### .NET

<a id="regularDesktopReference2021001"></a>
#### 正規表現オブジェクトを生成する

<a id="regularDesktopReference2021002"></a>
#### 文字列に対するマッチを行う

<a id="regularDesktopReference2021003"></a>
#### 文字列の置換を行う

<a id="regularDesktopReference1000001"></a>
### INTRODUCTION

<a id="regularDesktopReference1010100"></a>
#### 正規表現とは何か

<a id="regularDesktopReference1010100"></a>
#### 正規表現とは何か

<a id="regularDesktopReference1010200"></a>
#### 正規表現の用途

<a id="regularDesktopReference1010300"></a>
#### 正規表現をサポートする処理系

<a id="regularDesktopReference1010400"></a>
#### 正規表現の歴史

<a id="regularDesktopReference1010500"></a>
#### 正規表現の背景

<a id="regularDesktopReference1010600"></a>
#### 正規表現と文字コード

<a id="regularDesktopReference1010700"></a>
#### 正規表現用語リファレンス


<a id="memo1999"></a>
### 個人メモ


ーーー 最終行 ーーー
<!-- vim:set ts=4 sts=4 sw=4 tw=0: -->
