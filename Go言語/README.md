# Go言語
ここは、プログラミング言語のGo言語を勉強するブランチになる。  

## ブランチの利用方法

### 勉強方法
本格的に勉強するプログラミング言語の一つとしている。  
[公式ドキュメント](https://golang.org/doc/)  
[とほほのGo言語入門](https://www.tohoho-web.com/ex/golang.html)  
[Go言語の記述の迷いどころについて](https://zenn.dev/nobonobo/articles/19c84c231aff46)  


### 開発環境
できる限り`MacVim`を使うつもり。  
開発規模が大きくなった場合、`Visual Studio Code(VSCode)`に逃げるかもしれない。  
そうならないように、Vimエディタの環境も整備していこうと思う。  

### Pythonで学ぶアルゴリズムの教科書
簡単なプログラミングに使う基礎知識を統一する。  

* 基礎知識5種類  
  * [x] 変数  
  * [ ] 配列  
  * [ ] 条件分岐  
  * [ ] 繰り返し  
  * [ ] 関数  

#### 具体的な基礎知識
何はともあれ、まずは、"Hello World"を表示するプログラムを作る。  
そのため、以下の手順で勉強を進めることにする。  

[x] 手順1. 勉強用のブランチに移動する。  
[x] 手順2. ルートディレクトリのひな形ディレクトリをコピーしてくる。  
[x] 手順3. コピーしてきたディレクトリ名を"基礎知識用の勉強"に変更する。  
[x] 手順3-1. `helloWorld.[言語用の拡張子]`のファイルを作り、おなじみ"Hello World."プログラムを作る。  
[x] 手順3-2. main関数不要であれば、"**実行済み**"ディレクトリ不要になるはず、削除すること。  
           必要(削除不要)。  
[x] 手順3-3. コミットする。  
[ ] 手順4. 各ディレクトリで、5種類(変数・配列・条件分岐・繰り返し・関数)の"絶対的に勉強する一覧"を勉強する。  
[ ] 手順4-1. 箇条書きごとに勉強を進める。  
[ ] 手順4-2. 箇条書きごとに勉強を終えることで、コミット実施する。  
[ ] 手順4-3. 次の箇条書きに移り、勉強を継続(再開)する。  
[x] 手順4-X. 変数などの勉強で箇条書きごとにコミットは辛いよね。  
[ ] 手順5. 1つのプログラミング言語で、手順4の勉強1種類を終えた時に、次のプログラミング言語に移る。  
           (細かく分けることでやる気が維持される・・・はず)  
[ ] 手順6. 上記、5種類の基礎知識を終わるまで繰り返す。  
[ ] 手順7. 5種類の基礎知識終了にて、"study2programming"ブランチにマージする。  

勉強環境のコンパイルバージョン：go1.15.2  
ちょっと古いな。  

```terminal:go
$ go version
go version go1.15.2 darwin/amd64
$
```

プログラムファイルの拡張子：`*.go`  
　　https://play.golang.org  
標準の文字コード(プログラムファイル)：？  
文字区切り(行末記号)：波括弧`{}`の位置・要は改行(セミコロンなど行末に付けるものはない)  
インデント：タブ文字・波括弧`{}`の位置  
標準の出力関数：
`fmt.Print`(出力後の改行なし)
`fmt.Println`(出力後の改行あり)  
`fmt.Printf`(書式付き出力)  


#### 変数  
変数について勉強する。  

* 他の話題例  
  * [x] 定数  
  * [x] データ型  
     * [x] 整数  
     * [x] 浮動小数点型  
     * [x] 複素数型  
     * [x] 文字列型  
     * [x] 真偽型  
     * [x] 型推論  
  * [ ] リテラル  
     * [ ] 整数リテラル  
     * [ ] 浮動小数点リテラル  
     * [ ] 文字リテラル  
     * [ ] 文字列リテラル  
  * [ ] キャスト  
     * [ ] 暗黙返還  
     * [ ] 明示変換  
  * [ ] 演算子  
     * [ ] 算術演算子  
     * [ ] 優先順位  


##### 変数  
他のプログラミング言語では珍しく、複数バイトを変数名にできる。  
しかし、昔ExcelのVBAで多バイトを使った変数名のプログラムに関わることがあったとき、私は多バイトを変数名にするのは止めようと思った。  
それほど醜いプログラムになるため、通常は英数文字にしたほうがいい。  

* 変数宣言の省略  
  関数内に限り、省略が出来る。
  * 本来：var asakuno string
  例）var aName, bName string = "asakuno.txt", "tomohiro.md"
  * 省略：name := "asakuno"
  例）aName, bName := "asakuno.txt", "tomohiro.md"
  `string`も省略してる(型推論)。  


```go:変数.go
package main

import "fmt"

func main() {
	// 以下、変数宣言の省略。
	asakuno := 20210807
	// 以下、変数宣言付き。
	var tomohiro = 1813

	var (
		朝来野 float32 = 35.64849
		智博  float64 = 139.718305
	)

	// 以下、定数。
	const 朝来野智博, go勉強 = "朝来野 智博", "頑張るぞぉ"

	fmt.Println(asakuno, tomohiro)
		// 出力結果：20210807 1813
	fmt.Printf("今日は%vです。\n桁を増やして%vです。\n", 朝来野, 智博)
		// 出力結果：今日は35.64849です。
		// 桁を増やして139.718305です。
	fmt.Print(朝来野智博, go勉強)
		// 出力結果：朝来野 智博頑張るぞぉ
}
```

##### データ型  

* 整数型  

|  型  | 説明 | 範囲 |
|------|------|------|
|uint8|符号なし8ビット整数|0〜255|
|uint16|符号なし16ビット整数|0〜65535|
|uint32|符号なし32ビット整数|0〜4294967295|
|uint64|符号なし64ビット整数|0〜18446744073709551615|
|int8|符号あり8ビット整数|-128〜127|
|int16|符号あり16ビット整数|-32768〜32767|
|int32|符号あり32ビット整数|-2147483648〜2147483647|
|int64|符号あり64ビット整数|-9223372036854775808〜9223372036854775807|
|uint|32ビットまたは64ビットの符号なし整数(システム依存)|
|int|32ビットまたは64ビットの符号あり整数(システム依存)|
|uintptr|ポインタ値をそのまま保存するのに十分な大きさの符号なし整数|
|byte|バイトを表現する符号なし8ビット整数|0〜255|
|rune|Unicodeを表現する符号あり32ビット整数|-2147483648〜2147483647|

`long`型がなくて驚く。  

* 浮動小数点型(実数型)  

|  型  | 説明 | 範囲 |
|------|------|------|
|float32|IEEE-754, 32ビット浮動小数点数|
|float64|IEEE-754, 64ビット浮動小数点数|

* 複素数型  

|  型  | 説明 | 範囲 |
|------|------|------|
|complex64|float32の実数部と虚数部を持つ複素数|
|complex128|float128の実数部と虚数部を持つ複素数|

* 文字列型
0文字以上の文字からなる文字列の値を指す。  
型は`string`。  
要素は、`byte`型の配列扱いするため、`a = "askuno"`の場合、`a[0]==a``a[5]==o`になる。  
要素数は、`len()`関数で調べることができる。  

```go:データ型.go
	asakuno := "朝来野智博"
	var tomohiro string = "asakuno tomohiro"

	fmt.Println(asakuno, len(asakuno))	// 朝来野智博 15
	fmt.Println(tomohiro, len(tomohiro))	// asakuno tomohiro 16
```

多バイトの場合は、1文字3バイトのようだ。  

* 真偽型  

|  型  | 説明 | 範囲 |
|------|------|------|
|true|比較した結果が等しければ`true`になる。|
|false|比較した結果が等しくなければ`false`になる。|

```go:
func main() {
	asakuno := "朝来野智博"

	fmt.Println(asakuno == "朝来野智博")  // true
	fmt.Println(asakuno == "朝来野 智博") // false
}
```

Go言語での真偽値は、この2種類しか存在しない。  
※他のプログラミング言語では、`1`とか`0`で代替する。もしくは、補える場合がある。  

* 配列型  
* スライス型  
* 構造体型  
* ポインタ型  
* 関数型  
* インタフェイス型  
* マップ型  
* チャネル型  
* キャスト(型変換)  

##### リテラル  

##### キャスト  

##### 演算子  

* 二項演算子  
* 単項演算子  
* 比較演算子  
* 論理演算子  
* 代入演算子  
* アドレス演算子  
* 送受信演算子  
* 演算子の優先順位  

#### 配列  
配列について勉強する。  

* 絶対的に勉強する一覧  
  * [ ] 一次元配列  
  * [ ] 多次元配列  
     * [ ] 二次元配列  
     * [ ] 三次元配列  
     * ※複雑さに応じて対応する。  






#### 条件分岐  
条件分岐について勉強する。  

* 絶対的に勉強する一覧  
  * [ ] 単純分岐-"もし"1つ。  
    基本構造例：if  
  * [ ] 多岐分岐-"もし"2つ以上。  
    基本構造例：if〜else if  
  * [ ] 多岐分岐-条件にて複数から選ぶ。  
    基本構造例：switch  






#### 繰り返し  
繰り返しについて勉強する。  

* 絶対的に勉強する一覧  
  * [ ] 真偽条件での繰り返し  
    基本構造例：while( 条件式 )  
    基本構造例：do〜while( 条件式 )  
  * [ ] 指定回数条件での繰り返し  
    基本構造例：for( 条件式 )  
    基本構造例：拡張for命令  
  * [ ] ジャンプ処理  
    * [ ] break  
    * [ ] continue  






#### 関数  
関数について勉強する。  
Go言語には、 **クラスとオブジェクトはない**。  
しかし、Go言語には、 **メソッドがある**。  

* 絶対的に勉強する一覧  
  * [ ] 使い回せるようにまとめること。  
    * [ ] 引数  
    * [ ] 戻り値  






### Gitのマージルール
当ブランチでGo言語の勉強をする。  
以下、流れとして、、、

* 当ブランチ）  
  1. 当ブランチで勉強する。  
  1. 切りの良い場所でコミット実施。  

  * 上記作業再開。  
    1. 前回の勉強を再開する。  
    1. 1章分の勉強終了後、"study2programming"にマージする。  
    1. 誤字脱字程度のコミットはスカッシュしたい。  
    1. "study2programming"をPushする。  
    ※masterにマージすることはない。  
    1. 章ごとにタグ付けをする(Push実施)。  

study2programmingに取り込むときのマージは、3方向マージ(`--no-ff`)を使う。  
例外作業として、masterに取り込む場合はチェリーピッキングでピンポイントに必要最小限のコミットのみを取り込む(しつこいが、masterに取り込むことはしたくない)。  

以上。
