# Rust言語
ここは、プログラミング言語のRust言語を勉強するブランチになる。  


## 構造化プログラミング
※プログラミングに使う基礎知識を統一する(簡単に済ませられる量に絞り込む)。  
* 基礎知識5種類  
  * [x] [変数](#variable変数)  
  * [x] [配列](#arrangement配列)  
  * [x] [条件分岐](#Conditional条件分岐)  
  * [ ] [繰り返し](#repetition繰り返し)  
  * [ ] [関数](#function関数)  


<details><summary>基礎知識5種類の作業手順</summary>

## 具体的な基礎知識
何はともあれ、まずは、"Hello World"を表示するプログラムを作る。  
その後で、基礎中の基礎となる制御構造(構造化プログラミング)を簡略化しながら勉強する。  
そのため、以下の手順で勉強を進めることにする。  

* 以下、手順。  
  * [x] 手順1. 勉強用のブランチに移動する。  
  * [x] 手順2. ルートディレクトリのひな形ディレクトリをコピーしてくる。  
  * [x] 手順3. コピーしてきたディレクトリ名を"基礎知識用の勉強"に変更する。  
  * [x] 手順3-0. ここまでは、上位ディレクトリにある"README.md"で作業を終えているはず。  
  * [x] 手順3-1. 当ファイル(`README.md`)の書き換えを行う。  
        ※ **上位ディレクトリにある"README.md"** は触らない。  
        ※勉強項目は転記するが、実際の具体的な勉強項目は記載しないことにする(見にくくて仕方ない)。  
  * [x] 手順3-2. `helloWorld.[言語用の拡張子]`のファイルを作り、おなじみ"Hello World."プログラムを作る。  
  * [ ] 手順3-3. main関数不要であれば、"**実行済み**"ディレクトリを削除すること。  
  * [x] 手順3-4. コミットする。  
  * [ ] 手順4. 各ディレクトリで、5種類の"絶対的に勉強する一覧"を勉強する。  
    * 以下、5種類の内訳。  
    [x] 変数  
    [x] 配列  
    [x] 条件分岐  
    [ ] 繰り返し  
    [ ] 関数  
  * [ ] 手順4-1. 箇条書きごとに勉強を進める。  
  * [ ] 手順4-2. 箇条書きごとに勉強を終えることで、コミット実施する。  
  * [ ] 手順4-3. 次の箇条書きに移り、勉強を継続(再開)する。  
  * [x] 手順4-X. 変数などの勉強で箇条書きごとにコミットは辛いよね。  
  * [ ] 手順5. 1つのプログラミング言語で、手順4の勉強1種類を終えた時に、次のプログラミング言語に移る。  
         (細かく分けることでやる気が維持される・・・はず)  
  * [ ] 手順6. 上記、5種類の基礎知識を終わるまで繰り返す。  
  * [ ] 手順7. 5種類の基礎知識終了にて、"study2programming"ブランチにマージする。  

</details>


### ※注意事項
アルゴリズムを勉強することが目的であるため、理解すること。  
しかし、やる気を維持するためにも1冊分を読了させることも目的であるため、深掘りせずに進めることも考慮すること。  
要は、深く踏み込むか、流し読み程度に抑えるかどうかはそのときに決める。  

何より、書籍記載のアルゴリズムは、サンプルとして公式ページからダウンロードできる。  
そのため、書籍通りに進めるわけには行かず、自分なりに理解できるやり方で勉強した場合、当然ながら時間が掛かり、踏み込む必要が発生するだろう。  
それでも読了も達成したいため、なかなか両立は、難しい・・・と思い込んでいるが、実際は流し読み程度に抑え、サクサク勧めていこうと思う。

<a name="variable変数"></a>
<a name="arrangement配列"></a>
<a name="Conditional条件分岐"></a>
<a name="repetition繰り返し"></a>
<a name="function関数"></a>
<details><summary>基礎知識5種類の各項目</summary>

基礎知識として、5種類を勉強するが、その目的はアルゴリズムの勉強用であって、5種類を本格的に極めるためではない。  
そのため、1つ1つを最小限に絞り込み、1つを10分前後の勉強時間に収まるように気をつけること。  

#### 概要。
* [変数](#variable変数sub)  
  * 変数の宣言方法  
    数値の代入  
    文字列の代入  
    代入したそれらの出力  
  * 代入した値の変更方法  
    変数を用いた計算  
    * 計算用演算子の説明  
    * データ型の説明  
      数値-整数型  
      数値-小数型  
      文字列  
      論理値  
    * データ型の変換(キャスト)  
  * ※スコープは"関数"で説明する。  

* [配列(リスト)](#arrangement配列sub)  
  * 宣言方法  
    要素  
    要素数  
    添え字(インデックス)  
  * 要素追加方法  
  * 2次元配列  
  * ※取り出しは"for"で説明する。  

* [条件分岐](#Conditional条件分岐sub)  
  * if文  
    条件式  
    * if文からの派生  
      if〜elif〜else  
    * 演算子  
      論理演算子  
      比較演算子  

* [繰り返し](#repetition繰り返しsub)  
  * for文  
    条件式  
    多重(入れ子)利用  
    break  
    continue  
    拡張for文  
    　例）range  
    配列からの取り出し。  
  * while文  
    条件式  
    無限ループ  

* [関数](#function関数sub)  
  書式  
  引数  
  戻り値  
  * 組み合わせ  
    引数無し-戻り値無し  
    引数あり-戻り値無し  
    引数無し-戻り値あり  
    引数あり-戻り値あり  
  * 変数の有効範囲(スコープ)  
    グローバル変数  
    ローカル変数  

</details>

<a name="variable変数sub"></a>
### 変数
値の格納方法について。  
※複雑な説明はしない。  

* 絶対的に勉強する一覧  
  * [変数の宣言方法](#subVariable1)  
  * [変数への代入方法及び変数の利用](#subVariable2)  
    * [x] 代入演算子(`=`)  
      Rustでは、代入のことを"束縛(binding)"と呼ぶ。  
  * [変数値の出力方法](#subVariable3)  
  * [データ型](#subVariable4)  
    * [x] 整数(`int`)  
      32ビットや64ビット版がそう？
    * [ ] 浮動小数点型(`float`)  
    * [x] 文字型(`string`)  
      `&str`  
      `char`  
      `String`  
    * [x] 真偽型(`bool`)  
      trueやfalseが使える。  
  * [変数値を使った計算方法](#subVariable5)  
    * [ ] 算術演算子  
      * [x] 足し算(`+`)  
      * [x] 引き算(`-`)  
      * [x] 掛け算(`*`)  
      * [x] 割り算(`/`)  
      * [ ] 累乗(`**`)  
        ない？  
      * [ ] 割り算の商(`//`)  
        ない？  
      * [x] 割り算の余り(`%`)  
  * [型変換(キャスト)方法](#subVariable6)  
    * [x] 明示変換  
      `as [変換したい型]`  

<a name="subVariable1"></a>
#### 変数
型の宣言が必須。  
しかし、型推論させるのが一般的。  
様式：
`let 変数名;`

<a name="subVariable2"></a>
#### 変数への代入方法及び変数の利用
※Rustでは、代入のことを"束縛(binding)"と呼ぶ。  
以下の`mut`を付けた場合に変数の書き換えが可能になる。  
しかし、通常のRust言語でプログラム作成をする場合は、変数書き換え不要(`mut`なし変数)なプログラムを組むように心がけるべきである。  

様式：
`let mut 変数名 = 数値;`  
`let mut 変数名 = "文字列";`  
数値例）
`let mut days = 20210912;`  
文字列例）
`let mut strings = "Hello World.";`  

型を付けた宣言：
変数後に`:`を付け、さらにその後ろに型を付ける。  
`let mut 変数名 : 型 = 数値;`
`let mut 変数名 : 型 = "文字列";`
数値例）
`let mut days : i32 = 20210912;`  
`let mut days : i64 = 20210912;`  
`i32`は整数の32ビット版。`i64`は整数の64ビット版。  
文字列例）
`let mut strings : &str = "Hello World.";`  

* 変数宣言  
  * `let`により、変数宣言が可能になる。  
    この後ろに付く文字列が変数名になる。  
    また、これだけでは[定数](#subVariable2const)扱いになる。  
  * `let`の後ろに、`mut`を付けてから変数名を付けた場合、書き換え可能な変数宣言になる。  
    **mutable** (可変)の頭文字3文字。  

```Rust
fn main() {
//  let const_hoge = 20210912;	// warning: variable `const_hoge` is assigned to, but never used
//  const_hoge = 20210913;		// warning: value assigned to `const_hoge` is never read
			// letを使った変数宣言の場合、書き換えることが出来ない。

	let mut hoge = 20210912;	// warning: value assigned to `hoge` is never read
			// 一度も使わずに値を書き換えたため、警告が出た。
			// println!("出力：{}", hoge);
			//	これで変数を利用することにより、警告が出なくなる。
	hoge = 20210913;

	println!("出力：{}", hoge);
}
```

* 文字  
  * 1文字の代入方法は、シングルクォーテーション(`''`)で囲む。  


<a name="subVariable2const"></a>
##### 定数(Rust固有の"束縛(bind)")
以下の宣言した変数に、後から値を書き換えた場合、エラーになる。  

変数を使い回す場合、考慮範囲が広がるため、初期設定で書き換え不可能(束縛)な状態にしてある。  
逆に言えば、不意な書き換えに気づきやすくなっている。  
そのため、通常は、書き換え不可なまま使うべきである。  
それには、`let`により、同じ変数名を使い回すことができる(`let`を付けることで同名ではあるが、別物として扱われる：**シャドーイング**と言う。)。  
シャドーイングをする場合、代入する型を変えても問題ない(別物なので)。  

様式：
`let 変数名 = 数値;`  
`let 変数名 = "文字列";`  
数値例）
`let days = 20210912;`  
文字列例）
`let strings = "Hello World.";`  

型を付けた宣言：
変数後に`:`を付け、さらにその後ろに型を付ける。  
`let 変数名 : 型 = 数値;`
`let 変数名 : 型 = "文字列";`
数値例）
`let days : i32 = 20210912;`  
`let days : i64 = 20210912;`  
`i32`は整数の32ビット版。`i64`は整数の64ビット版。  
文字列例）
`let strings : &str = "Hello World.";`  
文字列の場合は、`&str`が文字列の型になる。  
付けるのが煩わしいため、普通は省略する。  
もっと言えば、型推論させる。  
しかし、[関数](#function関数sub)の引数には型付けが必須になる。  

変数名の規則もあるようだ。  
変数に大文字を使ってはならない？  

<a name="subVariable3"></a>
#### 変数値の出力方法

変数値の書き換え後の出力
```rust
fn main() {
//  let const_hoge = 20210912;	// warning: variable `const_hoge` is assigned to, but never used
//  const_hoge = 20210913;		// warning: value assigned to `const_hoge` is never read
			// letを使った変数宣言の場合、書き換えることが出来ない。

	let mut hoge = 20210912;	// warning: value assigned to `hoge` is never read
	hoge = 20210913;

	println!("出力：{}", hoge);
}
```

1文字出力
```rust
let a = 'a';
let cat = '😻';
// let dog = 'dog';	// error: character literal may only contain one codepoint	1文字ではないのが原因だろう。
println!("a  ：{}", a);		// a  ：a
println!("cat：{}", cat);	// cat：😻
```

文字列出力
```rust
let hogestr = "hoge string.";
let boostr = "boo string.";
println!("文字列  ：{}", hogestr);	// 文字列  ：hoge string.
println!("文字列  ：{}", boostr);	// 文字列  ：boo string.
// let a_t_str = hogeastr + " " + boostr;	// error[E0369]: cannot add `&str` to `&str`
let a_t_str = format!("{}と{}を連結", hogeastr, boostr);	// 
println!("a_t_str ：{}", a_t_str);	// a_t_str ：朝来野智博とboo string.を連結
```

文字列の抜き出し。
```rust
fn main() {
	let hoge = "本日は晴天なり。本日は晴天なり。";

//  let tomohiro = &asakuno[2..5];
//  println!("エラー？：{}", tomohiro);
	// thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside '本' (bytes 0..3) of `本日は晴天なり。本日は晴天なり。`', main.rs:73:21

	let mut vhogev : Vec<char> = Vec::new();	//	←☆この変数にUTF-8文字列から切り出してchar型に変換した文字を追加していく。
	for c in hoge.chars() {
		vhogev.push( c );
	}
	let vhogev = &vhogev[2..5];	//	←☆このままで扱いづらい。
	// 再び&Stringに戻す。
	let mut hoge = String::new();
	for c in vhogev {
		hoge.push( *c );
	}
	println!("抜き出し結果：{}", hoge);	// 抜き出し結果：は晴天
}
```

<a name="subVariable4"></a>
#### データ型

|データ型|サイズ|備考|
|--------|------|----|
|int|||
|float|||
|string|||
|bool|||

整数型
|ビット長|整数|符号なし整数|備考|
|--------|----|------------|----|
|8ビット|i8|u8|
|16ビット|i16|u16|
|32ビット|i32|u32|
|64ビット|i64|u64|現在主流のパソコンで使われている。|
|処理系依存|isize|usize|効率の良いビット数が使われる。|

* 浮動小数点数  
  * 固定小数点数  
    実数の整数部と少数以下を別々に扱う。  
    例）`100.234`の場合、整数`100`と小数点以下`234`を別々に扱う。  
  * 浮動小数点数  
    数値部分と指数部分を別々に扱う。  
    例）`100.234`の場合、数値部分`1.00234`と指数部分`10の2乗`を別々に扱う。  
    数値部分が固定のため、有効桁数を保って計算できるのが利点になる。  

* Bool型(論理値型)  
  * `true`  
    真  
  * `false`  
    偽  

* 文字型
  ユニコードもしくはUTF-8エンコードを使う。  
  そのため、文字列操作は、UTF-8と配列が複雑な絡み方をしているため、気をつける必要がある。  
  * 文字  
    1文字(`char`型)。  
    1文字32ビット(4バイト)。  
    そのため、漢字・平仮名・片仮名・絵文字などが1文字として扱える。  
    ※シングルクォーテーションで囲む。  
  * 文字列  
    char型の連なりではない。  
    ※**所有権(ownership)**・**借用(borrow)** の問題がある。  
    ※ダブルクォーテーションで囲む。  
    * 複数文字(`&str`型)。  
      `let hoge = "hoge";`の場合`&str`型になるようだ。  
      `format!`関数だけの利用で文字列の連結が出来るように見せかけられる。  
      ※基本的には固定文字列と思うべし。  
    * 複数文字(`String`型)。  
      `let hoge = "Hello World.".to_string();`のように宣言する。  
      `let hoge = String::from("Hello World.");`のように宣言する。  
      `&str`が達と違い、`+`による文字の連結が可能(当然`format!`関数での連結可能)。  
      ※基本的には可変文字列として扱う。  
    * 文字列から適当な文字を抜き出す場合、クレート(他のプログラミング言語で言うライブラリのことのようだ)もしくは、char型配列に置き換えてから抜き出す。  
      本来であれば、UTF-8の文字列を適切に扱うには、[Rust Package Registry](https://crates.io)から適切なライブラリを使う必要がある。  

特殊文字
|文字|文字リテラル|備考|
|----|------------|----|
|`'`|`\'`|シングルクォート表示方法|
|`\`|`\\`|バックスラッシュ表示方法|
|改行記号|`\n`|
|復帰記号|`\r`|キャリッジリターン|
|タブ記号|`\t`|
|16進数でASCII文字|`\xHH`|`HH`数字|
|Unicode|`\u{HHHHHH}`|`HHHHHH`|

* 複雑な変数宣言時の利用種類  
  * 型(クラス)  
  * トレイト  

* 複合型  
  * タプル型  
    構造体より簡単に扱える(使い方は構造体のような感じ)。  
  * 構造体  
  * [配列型](#arrangement配列sub)  
    宣言時から幅を変更できず、中身(要素値)も変更できない。  
  * ベクター型  
    要素の追加・削除・変更が可能。  

* 参照と借用  
  所有権(ownership)・移動(move)・借用(borrow)を使いこなすことで、安全にプログラミングができる。  
  * 参照  
  * 借用  
    文字列を代入している変数を他の変数に代入した場合、移動することになり、元の変数を他の処理で使うときに借用が出来なくなる。  

* 書籍の誤字
  * 所有権  
    10章の10.1の1段落目「略）〜表だっては見えないけれども協力かつ重要な機能を〜（略」ここでの"協力"は、**強力**のはず。  

```Rust
fn main() {
	let strx = String::from("hoge");
	let stry;
	println!("strx：{}", strx);	// strx：hoge
	stry = strx;	// 変数値を移動した(コピーではない)。
	println!("stry：{}", stry);	// stry：hoge
	println!("strx：{}", strx);	// エラーになる。
			// error[E0382]: borrow of moved value: `strx`
}
```

<a name="subVariable5"></a>
#### 変数値を使った計算方法

|演算子|意味|備考|
|------|----|----|
|`+`|加算||
|`-`|減算||
|`*`|乗算|参照外しの意味も含まれるため、気をつけること。|
|`/`|除算|コメント記号に使われるため、気をつけること。|
|`**`|累乗||
|`//`|除算の商||
|`%`|剰余演算||

```rust
fn main() {
	let cal = 20 + 10;
	println!("20 + 10 = {}", cal);	// 20 + 10 = 30
	let cal = 20 - 10;
	println!("20 - 10 = {}", cal);	// 20 - 10 = 10
	let cal = 20 * 10;
	println!("20 * 10 = {}", cal);	// 20 * 10 = 200
	let cal = 20 / 6;
	println!("20 /  6 = {}", cal);	// 20 /  6 = 3
	let cal = 20.0 / 6.0;	// 両方を浮動小数点数にする必要があるようだ。
	println!("20.0/6.0= {}", cal);	// 20.0/6.0= 3.3333333333333335
	let cal = 20 % 6;
	println!("20 %  6 = {}", cal);	// 20 %  6 = 2
}
```

この他に、`a += 20;`など(`-=`・`*=`・`/=`)もできる(代入演算子)。  

<a name="subVariable6"></a>
#### 型変換(キャスト)方法
暗黙変換はない。  

様式：
`as [変換したい型]`  

```rust
let decimal = 65.4321_f32;
let integer = decimal as u8;
let character = integer as char;
```

##### u8型変換(キャスト)方法
1文字用のキャストコマンド：  
u8型に変換：`as u8`  
char型に変換：`as char`  

u8型に変換例）
`変数名 as u8;`  
```rust
let ch = 'A';
let u = ch as u8;	// u8型に変換。
```

char型に変換様式：
`変数名 as char;`  
char型に変換例）
```rust
// 上記のu変数を使う。
let ch = u as char;	// char型に変換。
```

この変換方法は、char型のみに有効。  
その理由は、Rust言語は1文字4バイトだが、C言語やC++言語は1文字1バイトになっており、それらのライブラリと連携することができるため、このような相互変換がスムースにいくような設計になった。  


<a name="subVariable6array"></a>
#### 配列の型変換(キャスト)方法
配列からキャストする場合は、`std::mem::transmute`関数を使う。  
また、強制キャストをする場合は、`unsafe`ブロックで囲み、コンパイルエラーを抑止する必要がある。  

以下、8ビット数値から64ビット数値に強制変換する。
```rust
// 方法不明。
```


<a name="subVariable999"></a>
#### 変数での説明しない項目。

<details><summary>今回は勉強を見送る一覧</summary>

* [x] 定数  
  `let`だけの変数宣言とは違う？  
* [ ] データ型  
  * [ ] Result型  
  * [ ] 整数(`long`など)  
  * [ ] 浮動小数点型(`double`など)  
  * [x] 型推論  
  * [ ] 複素数型  
* [ ] リテラル  
  * [x] 整数リテラル  
  * [ ] 浮動小数点リテラル  
  * [ ] 文字リテラル  
  * [ ] 文字列リテラル  

数値リテラル
|数値リテラル|例|
|------------|--|
|10進数|12\_345|
|16進数|0xff|
|8進数|0o77|
|2進数|0b1111\_0000|
|1バイト|b'A'|


* [ ] キャスト  
  * 暗黙変換  
    存在しない。  
* [ ] 演算子  
  * [ ] ビット演算子  
  * [ ] シフト演算子  
  * [ ] 単項演算子  
  * [ ] 優先順位  

* ちょっと高度な話題  
  * [ ] ポインタ  

* 関数を変数に代入  
* 関数を引数に使う  

</details>


<a name="arrangement配列sub"></a>
### 配列
変数を連ならせる格納方法。  
今回のPythonではリストを配列と呼ぶ。  
※配列とリストを分けている場合はリストの勉強を後回しにし、配列がない状態でリストがある場合はリストを勉強する。  

* 絶対的に勉強する一覧  
  * [x] [配列の宣言方法](#subArrangement1)  
        [x] 要素とは。  
        [x] 要素数とは。  
        [x] 添え字とは。  
        0から数える。  
  * [x] [配列への追加方法](#subArrangement2)  
    `mut`を付けることで書き換え可能になる。  
  * [x] [二次元配列の宣言方法](#subArrangement3)  
    `let mut 配列名 = [[1, 2, ], [3, 4, ], ];`  


<a name="subArrangement1"></a>
#### [配列](https://doc.rust-jp.rs/rust-by-example-ja/primitives/array.html)
コレクションのひとつ。  
しかし、配列の場合は、ベクター型と違い、要素数を変えることが出来ない(配列の長さが固定になる)。  
配列では、要素内容も変更できない。  

様式：
`let 配列名 = [値1, 値2, ・・・];`  

* 配列定義(色々省略形)  
  * 要素数はコンパイル時に決まるため、省略可能。  
  * 代入値の型も推論されるため、省略可能。  

例）
`let array = [1, 2, 3];`  
※`mut`がないため、値の変更不可。  

* 配列定義(型明記)  
  * 型指定する場合、要素数の明記も必須(省略不可)。  

[配列のキャスト方法](#subVariable6array)残念ながら不明。  


<a name="subArrangement2"></a>
#### 配列への追加方法
[変数への書き換えと同じ](#subVariable2)で、`mut`を付ける必要がある。  
様式：
`let mut 配列名: [型; 要素数] = [値1, 値2, ・・・ ];`  


以下、プログラム例）
```rust
fn main() {
	let hoge = ["本日は", "晴天なり"];
	let num = 1;

	println!("[0]：{}", hoge[0]);				// [0]：本日は
	println!("[1]：{}", hoge[num]);				// [1]：晴天なり
	println!("hoge配列の長さ：{}", hoge.len());	// hoge配列の長さ：2
	println!("-----------------------------------------");

	// 以下、型指定の配列
	let boo: [i32; 2] = [20211003, 20211004];
	println!("[0]：{}", boo[0]);				// [0]：20211003
	println!("[1]：{}", boo[1]);				// [1]：20211004
	println!("boo配列の長さ：{}", boo.len());	// boo配列の長さ：2

	println!("-----------------------------------------");
	let array: [i64; 0] = [];	// 空配列宣言成功(型指定必須)
	println!("array配列の長さ：{}", array.len());	// array配列の長さ：0

	println!("-----------------------------------------");
	// 以下、　1回の代入で全ての要素を同じ値に設定する(後から変更可能にもしておく)。
	let mut bar: [i32; 5] = [20211003; 5];
	println!("[0]：{}", bar[0]);				// [0]：20211003
	println!("[4]：{}", bar[4]);				// [4]：20211003
	println!("bar配列の長さ：{}", bar.len());	// bar配列の長さ：5
	bar[0] = 20211004;
	bar[4] = 12345678;
	println!("[0]：{}", bar[0]);	// [0]：20211004
	println!("[3]：{}", bar[3]);	// [3]：20211003
	println!("[4]：{}", bar[4]);	// [4]：12345678
}
```


<a name="subArrangement3"></a>
#### 二次元配列の宣言方法
様式：
`let mut 配列名 = [[1次元配列目の値1, 1次元配列目の値2, ], [2次元配列目の値1, 2次元配列目の値2, ], ];`  

```rust
fn main() {
	let hoge = [
			[20211003, 20211004, ],
			[20211005, 20211006, ],
		];
	println!("2次元配列の1次元目[0]：{}", hoge[0][0]);	// 2次元配列の1次元目[0]：20211003
	println!("2次元配列の1次元目[1]：{}", hoge[0][1]);	// 2次元配列の1次元目[1]：20211004
	println!("2次元配列の2次元目[0]：{}", hoge[1][0]);	// 2次元配列の2次元目[0]：20211005
	println!("2次元配列の2次元目[1]：{}", hoge[1][1]);	// 2次元配列の2次元目[1]：20211006
}
```

<a name="subArrangement999"></a>
#### 配列での説明しない項目。

<details><summary>今回は勉強を見送る一覧</summary>

* キャスト方法  
  断念したため、もう一度調べる。  
  ※アルゴリズムの勉強で使うと思うので、、、きっと・・・。  

* 配列の応用  
  * [ ] 3次元配列以上の宣言方法。  
  * [ ] 配列を複製する方法。  
  * [ ] 配列からスライスを作成する方法。  

* 構造体  
  3.5.3の"構造体単位"のnew関数内のxと言う名前の型を調べる(他のプログラミング言語でもあるが、同じ意味か？)。  
  * [ ] トレイト  
  * [ ] スコープ  
  * [ ] 構造体の複製  
  * [ ] 構造体からのスライス作成  
  * [ ] 共用体  
  * [ ] 列挙体  

* コレクション  
  * [ ] List?  
  * [ ] Set  
  * [ ] Map  
  * [ ] Queue  

</details>


<a name="Conditional条件分岐sub"></a>
### 条件分岐

* 絶対的に勉強する一覧  
  * [x] [単純分岐-"もし"1つ。](#subConditional1)  
    基本構造例：if  
  * [x] [多岐分岐-"もし"2つ以上。](#subConditional1)  
    基本構造例：if〜else if〜  
  * [x] [論理演算子(ド・モルガンの法則)](#subConditional2)  
    * [x] 論理積(`AND`・`&&`)  
    * [x] 論理和(`OR`・`||`)  
  * [x] [比較演算子](#subConditional3)  
    * [x] 等しい(`==`)  
    * [x] 等しくない(`!=`)  
    * [x] より大きい(`>`)  
    * [x] より小さい(`<`)  
    * [x] 以上(`>=`)  
    * [x] 以下(`<=`)  

<a name="subConditional1"></a>
#### 条件分岐
様式：
`if 条件式 { 処理; }`  
条件式を丸括弧`()`で囲んだ場合、エラーになる。  

複数条件式
```rust
if 条件式1 {
    処理A;
} else if 条件式2 {
    処理B;
} else {
    処理C;
}
```

以下、実際の条件分岐処理。
```rust
fn main() {
	let mut a = 10;
	let mut b = 10;
	if a != b {
		println!("a!=b");
		// 出力結果：a!=b
	}

	a = 22;
	b = 33;

	if comparison( a, b) {
		println!("関数の戻り値(bool)を条件式とした。");
		// 出力結果：関数の戻り値(bool)を条件式とした。
	}

	if a == 22 && b == 33 {
		println!("a==22&&b==33");
		// 出力結果：a==22&&b==33
	}

	// 以下、三項演算子。
	let ret = if a < b {1} else {0};
	println!("a<bの比較結果：{}", ret);
		// 出力結果：a<bの比較結果：1
}

fn comparison( x: i32, y: i32 ) -> bool {
	x < y
}
```


<a name="subConditional2"></a>
#### 論理演算子(ド・モルガンの法則)

|演算子|意味|備考|
|------|----|----|
|`&&`|論理積|別表記`AND`|
|`||`|論理和|別表記`OR`|

<a name="subConditional3"></a>
#### 比較演算子

|演算子|意味|備考|
|------|----|----|
|`==`|等号||
|`!=`|不等||
|`>`|より大きい||
|`<`|より小さい||
|`>=`|以上||
|`<=`|以下||

<a name="subConditional999"></a>
#### 条件分岐での説明しない項目。

<details><summary>今回は勉強を見送る一覧</summary>

* 多岐分岐-条件にて複数から選ぶ。  
  基本構造例：switch  

* 関係演算子  
  * [x] 三項演算子(`?:`)  
    Rustでは書き方が異なる。  
  * [ ] 論理演算子  
    * [ ] 排他的論理和(`XOR`・`NOT OR`・`^`)  
    * [ ] 否定(`NOT`・`!`・`~`)  
    * [ ] ビット演算子(`&`・`|`)  

* 演算子の優先順位  

* 他の話題例  
  * [ ] 変数の比較  
  * [ ] 配列の比較  

* ジャンプ  
  * [ ] goto文  

</details>

<a name="repetition繰り返しsub"></a>
### 繰り返し

* 絶対的に勉強する一覧  
  * [ ] [指定回数条件での繰り返し](#subRepetition1)  
    [ ] [基本構造例：for( 条件式 )](#subRepetition2)  
    [ ] [基本構造例：拡張for命令(`in`)](#subRepetition3)  
    [ ] [`for`の入れ子。](#subRepetition4)  
  * [ジャンプ処理](#subRepetition5)  
    * [ ] break  
    * [ ] continue  
  * [ ] [真偽条件での繰り返し](#subRepetition6)  
    [ ] [基本構造例：while( 条件式 )](#subRepetition6)  
    [ ] [無限ループ](#subRepetition7)  


<a name="subRepetition1"></a>
#### 繰り返し
様式：

<a name="subRepetition2"></a>
##### 指定回数条件での繰り返し：for( 条件式 )
様式：

<a name="subRepetition3"></a>
##### 指定回数条件での繰り返し：拡張for命令
様式：

<a name="subRepetition4"></a>
#### `for`の入れ子。

<a name="subRepetition5"></a>
#### ジャンプ処理

<a name="subRepetition6"></a>
#### 真偽条件での繰り返し：while( 条件式 )
様式：

<a name="subRepetition7"></a>
#### 無限ループ
様式：

<a name="subRepetition999"></a>
#### 繰り返しでの説明しない項目。

[以下、今回の言語に関係の無い項目を削除すること(対象言語に存在するが、見送るもののみ、以下残す)。]  
<details><summary>今回は勉強を見送る一覧</summary>

* [ ] 真偽条件での繰り返し  
  基本構造例：do〜while( 条件式 )  
* [ ] イテレータ  

</details>

<a name="function関数sub"></a>
### 関数

todo: 引数の型を調べるBy.変数担当より。

* 絶対的に勉強する一覧  
  * [ ] 使い回せるようにまとめること。  
    * [ ] [引数と戻り値の組み合わせ。](#subFunction1)  
      [ ] 引数無し-戻り値無し  
      [ ] 引数あり-戻り値無し  
      [ ] 引数無し-戻り値あり  
      [ ] 引数あり-戻り値あり  
    * [スコープ](#subFunction2)  
      [ ] グローバルスコープ変数  
      [ ] ローカルスコープ変数  

<a name="subFunction1"></a>
#### 関数
様式：

<a name="subFunction2"></a>
#### スコープ

<a name="subFunction999"></a>
#### 関数での説明しない項目。

[以下、今回の言語に関係の無い項目を削除すること(対象言語に存在するが、見送るもののみ、以下残す)。]  
<details><summary>今回は勉強を見送る一覧</summary>

そもそもPythonは、普通に必要？  
しかし、アルゴリズムの勉強には不要なのだろう。  

* マクロ  
* 標準的な関数  
  * [ ] 可変長引数  
  * [ ] 再帰関数  
  * [ ] 高階関数  
    変数の応用部分で説明する？  
* オブジェクト指向  
  * [ ] クラスの定義  
  * [ ] フィールド  
  * [ ] メソッド  
  * [ ] コンストラクタ  
* オブジェクト指向  
  * [ ] カプセル化  
  * [ ] 継承  
  * [ ] ポリモーフィズム  
* オブジェクト指向  
  * [ ] 例外処理  
  * [ ] 列挙型  
  * [ ] 入れ子クラス  
  * [ ] ジェネリクス  
  * [ ] ラムダ式(無名関数？)(クロージャ？)  
* スコープ  
  * [ ] クロージャ  
  * [ ] 関数内の関数(コード3-42の中で参照できないと言うぐらいなのだからエラー内容を記載して欲しいよな)  

</details>


## Gitのマージルール
個々の言語ごとにブランチをそれぞれ作成する。  
そのブランチで作業する。  
以下、流れとして、、、

* ブランチ作成などの初期作業。  
  1. [ ] 対象言語のブランチ作成  
  1. [ ] そのブランチで勉強する。  
  1. [ ] 切りの良い場所でコミット実施。  

  * 上記作業再開。  
    1. [ ] 前回の勉強を再開する。  
    1. [ ] 1章分の勉強終了後、"study2programming"にマージする。  
    1. [ ] 誤字脱字程度のコミットはスカッシュしたい。  
    1. [ ] "study2programming"をPushする。  
       ※masterにマージすることはない。  
    1. [ ] 章ごとにタグ付けをする(Push実施)。  

study2programmingに取り込むときのマージは、3方向マージ(`--no-ff`)を使う。  
例外作業として、masterに取り込む場合はチェリーピッキングでピンポイントに必要最小限のコミットのみを取り込む(しつこいが、masterに取り込むことはしたくない)。  
あわよくば、Gitの勉強にもなればと思ったが、思った以上に難しい。  


以上。
<!-- vim: set ts=4 sts=4 sw=4 tw=0 expandtab: -->
